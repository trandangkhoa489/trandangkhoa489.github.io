<krpano>

	<!-- krpano 1.20.10 - Virtual Tour Skin -->


	<!-- skin settings (can be overridden in the tour.xml) -->
	<skin_settings maps="false"
	               maps_type="google"
	               maps_bing_api_key=""
	               maps_google_api_key=""
	               maps_zoombuttons="false"
	               maps_loadonfirstuse="true"
	               gyro="true"
	               gyro_keeplookingdirection="false"
	               webvr="true"
	               webvr_keeplookingdirection="true"
	               webvr_prev_next_hotspots="true"
	               autotour="false"
	               littleplanetintro="false"
	               followmousecontrol="false"
	               title="true"
	               thumbs="true"
	               thumbs_width="120" thumbs_height="80" thumbs_padding="10" thumbs_crop="0|40|240|160"
	               thumbs_opened="false"
	               thumbs_text="false"
	               thumbs_dragging="true"
	               thumbs_onhoverscrolling="false"
	               thumbs_scrollbuttons="false"
	               thumbs_scrollindicator="false"
	               thumbs_loop="false"
	               tooltips_buttons="false"
	               tooltips_thumbs="false"
	               tooltips_hotspots="false"
	               tooltips_mapspots="false"
	               deeplinking="false"
	               loadscene_flags="MERGE"
	               loadscene_blend="OPENBLEND(1.0, 0.0, 0.2, 0.0, linear)"
	               loadscene_blend_prev="SLIDEBLEND(0.5, 180, 0.75, linear)"
	               loadscene_blend_next="SLIDEBLEND(0.5,   0, 0.75, linear)"
	               loadingtext=""
	               layout_width="100%"
	               layout_maxwidth="814"
	               controlbar_width="-24"
	               controlbar_height="40"
	               controlbar_offset="20"
	               controlbar_offset_closed="-40"
	               controlbar_overlap.no-fractionalscaling="10"
	               controlbar_overlap.fractionalscaling="0"
	               design_skin_images="vtourskin.png"
	               design_bgcolor="0x2D3E50"
	               design_bgalpha="0.8"
	               design_bgborder="0"
	               design_bgroundedge="1"
	               design_bgshadow="0 4 10 0x000000 0.3"
	               design_thumbborder_bgborder="3 0xFFFFFF 1.0"
	               design_thumbborder_padding="2"
	               design_thumbborder_bgroundedge="0"
	               design_text_css="color:#FFFFFF; font-family:Arial;"
	               design_text_shadow="1"
	               />


	<!-- save the url path of this xml file (the url value will be adjusted during xml parsing) -->
	<vtourskinxmlpath url="./" />

	<!-- iPhone X safe-area support: use the horizontal safe-area only -->	
	<display safearea="h-only" />

	<!-- mouse / touch / keyboard(button) control settings - https://krpano.com/docu/xml/#control -->
	<control mouse="drag"
	         touch="drag"
	         zoomtocursor="false"
	         zoomoutcursor="false"
	         draginertia="0.1"
	         dragfriction="0.9"
	         movetoaccelerate="1.0"
	         movetospeed="10.0"
	         movetofriction="0.8"
	         keybaccelerate="0.09"
	         keybfriction="0.94"
	         keybfovchange="0.25"
	         mousefovchange="1.0"
	         fovspeed="3.0"
	         fovfriction="0.9"
	         bouncinglimits="true"
	         />

	<!-- mouse cursors - https://krpano.com/docu/xml/#cursors -->
	<cursors standard="default"
	         dragging="move"
	         moving="move"
	         />


	<!-- ensure stagescale 2x for mobile devices (regardless if mobilescale is 0.5 or 1.0) -->
	<krpano stagescale="calc:stagescale * 2" if="stagescale LT 1.0" devices="mobile" />


	<!-- VR support - https://krpano.com/plugins/webvr/ -->
	<include url="%VIEWER%/plugins/webvr.xml" devices="html5" />
	
	<!-- overwrite some settings from the webvr.xml for the skin integration -->
	<plugin name="webvr" keep="true" devices="html5.and.webgl"
	        url="calc:skin_settings.webvr == true ? '%VIEWER%/plugins/webvr.js' : null"
	        onavailable="skin_webvr_onavailable();"
	        onentervr="skin_showloading(false); webvr_onentervr(); skin_webvr_setup(); skin_reloadscene_webvr();"
	        onexitvr="webvr_onexitvr(); skin_webvr_setup(); skin_reloadscene_webvr();"
	        />
	
	<!-- webvr button style (adjust to match skin style) -->
	<style name="webvr_button_style"
	       bgroundedge="calc:skin_settings.design_bgroundedge"
	       bgcolor="get:skin_settings.design_bgcolor" bgalpha="get:skin_settings.design_bgalpha"
	       bgborder="get:skin_settings.design_bgborder"
	       bgshadow="get:skin_settings.design_bgshadow"
	       css="calc:skin_settings.design_text_css + ' font-size:' + 20*webvr_setup_scale*webvr_button_scale + 'px;'"
	       />
	
	<!-- show a 'rotate the device' info when the mobile device is in portrait orientation in VR mode -->
	<layer name="webvr_rotate_to_landscape_request" keep="true" vr="true" devices="mobile"
	       url="rotate_device.png" scale="0.5"
	       align="top" edge="center" y="28%"
	       autoalpha="true" alpha="0.0"
	       enabled="false"
	       />
	
	<events name="skin_webvr_and_gyro_events" keep="true" devices="html5"
	        onxmlcomplete="skin_set_webvr_or_gyro_startup_view()"
	        onresize.mobile="skin_webvr_act_as_gyro_in_portrait_mode();"
	        onloadcomplete="delayedcall(0.5, if(webvr.isenabled AND scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots, set(hotspot[skin_webvr_prev_scene].visible,true); set(hotspot[skin_webvr_next_scene].visible,true); ); );"
	        onviewchange=""
	        />
	
	<action name="skin_webvr_onavailable" scope="local">
		if(webvr.isvrbrowser,
			<!-- show a special enter VR screen for Gear VR browsers (Oculus Browser or Samsung Internet VR) -->
			set(layer[webvr_enterbutton], 
				align=center, y=0, padding='10 20', 
				css=calc(skin_settings.design_text_css + ' font-size:20px;text-align:center;'),
				html=calc((global.title ? '[i]'+global.title+'[/i][br]' : '') + '[span style="font-size:40px"]Enter VR[span]'), 
			);
			skin_hideskin(instant);
		  ,
			<!-- remove the enter vr button from the webvr.xml -->
			removelayer(webvr_enterbutton);
		);
				
		<!-- update the skin buttons to add the skin vr button -->
		skin_arrange_buttons();
			
		<!-- call the original onavailable event from the webvr.xml -->
		webvr_onavailable();
	</action>
	
	<action name="skin_set_webvr_or_gyro_startup_view">
		if( (webvr.isenabled == true AND skin_settings.webvr_keeplookingdirection == false) OR (!webvr.isenabled AND plugin[skin_gyro].enabled == true AND skin_settings.gyro_keeplookingdirection == false),
			skin_lookat( get(xml.view.hlookat) );
		);
	</action>
	
	<action name="skin_webvr_setup">
		if(webvr.isenabled,
			copy(skin_settings.loadscene_flags_backup, skin_settings.loadscene_flags);
			set(skin_settings.loadscene_flags, MERGE|KEEPVIEW|KEEPMOVING|NOPREVIEW);
			skin_webvr_act_as_gyro_in_portrait_mode(true);
			if(scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots,
				set(hotspot[skin_webvr_prev_scene].visible, true);
				set(hotspot[skin_webvr_next_scene].visible, true);
				set(events[skin_webvr_and_gyro_events].onviewchange, skin_webvr_menu_following());
			);
		  ,
			if(skin_settings.loadscene_flags_backup !== null, copy(skin_settings.loadscene_flags, skin_settings.loadscene_flags_backup); );
			if(layer[webvr_rotate_to_landscape_request], tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0); );
			set(hotspot[skin_webvr_prev_scene].visible, false);
			set(hotspot[skin_webvr_next_scene].visible, false);
			set(events[skin_webvr_and_gyro_events].onviewchange, null);
		);
	</action>
	
	<action name="skin_webvr_act_as_gyro_in_portrait_mode" scope="local" args="setupcall">
		if(device.mobile AND webvr.isenabled,
			div(aspect, stagewidth, stageheight);
			if(aspect != lastaspect OR setupcall == true,
				copy(lastaspect, aspect);
				if(stagewidth GT stageheight,
					<!-- landscape orientation - use stereo rendering and a direct/fast gyro sensor mode -->
					set(display.stereo, true);
					set(webvr.mobilevr_sensor_mode, 3);
					webvr.update();
					tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0);
				  ,
					<!-- portrait orientation - use normal rendering and a smoother/slower gyro sensor mode -->
					set(display.stereo, false);
					set(webvr.mobilevr_sensor_mode, 1);
					webvr.update();
					tween(layer[webvr_rotate_to_landscape_request].alpha, 1.0);
					delayedcall(3.0, tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 1.0); );
				);
			);
		  ,
			set(lastaspect, 0);
		);
	</action>
	
	<!-- VR scene switching hotspots -->
	<style name="skin_webvr_menu_style" torigin="view" depth="1000" scale="0.625" distorted="true" ath="0" atv="45" alpha="0.5" />
	<hotspot name="skin_webvr_prev_scene" keep="true" style="skin_base|skin_webvr_menu_style" crop="0|64|64|64"  ox="-88" onover="tween(scale,0.750);" onout="tween(scale,0.625);" vr_timeout="750" onclick="skin_nextscene_loop(-1);" visible="false" devices="html5.and.webgl" />
	<hotspot name="skin_webvr_next_scene" keep="true" style="skin_base|skin_webvr_menu_style" crop="64|64|64|64" ox="+88" onover="tween(scale,0.750);" onout="tween(scale,0.625);" vr_timeout="750" onclick="skin_nextscene_loop(+1);" visible="false" devices="html5.and.webgl" />
	
	<!-- floating/following VR hotspots -->
	<action name="skin_webvr_menu_following" type="Javascript" devices="html5"><![CDATA[
		var hs1 = krpano.get("hotspot[skin_webvr_prev_scene]");
		var hs2 = krpano.get("hotspot[skin_webvr_next_scene]");
		if(!hs1.hovering && !hs2.hovering)
		{
			var f = 0.01;	// following speed factor
			var h = krpano.view.hlookat;
			var v = krpano.view.vlookat;
			var hsh = hs1.ath;
			var hsv = hs1.atv;
			h   = (h  -(h|0))   + (((h|0)  +360180)%360) - 180.0;
			v   = (v  -(v|0))   + (((v|0)  +360180)%360) - 180.0;
			hsh = (hsh-(hsh|0)) + (((hsh|0)+360180)%360) - 180.0;
			var dh = h - hsh;
			dh += (dh > 180) ? -360 : (dh < -180) ? 360 : 0
			hsh += dh*f;
			var a = Math.abs(v - hsv) / 90.0;
			a = 1.0 * Math.max(1.0 - 2.0*Math.sqrt(a), 0);
			v = v + 55.0 - v*1.5;
			hsv = hsv*(1.0 - f) + v*f;
			hs1.ath = hs2.ath = hsh;
			hs1.atv = hs2.atv = hsv;
			hs1.alpha = hs2.alpha = a;
		}
	]]></action>
	<!-- VR support -->



	<!-- skin styles -->

	<!-- skin_base - the base skin image -->
	<style name="skin_base" url="calc:vtourskinxmlpath.url + skin_settings.design_skin_images" />


	<!-- skin_glow - button glowing -->
	<style name="skin_glow"
	       ondown.addevent="copy(skin_lockglow,name); skin_buttonglow(get(name));"
	       onover.addevent="if(skin_lockglow === null, copy(skin_lockglow,name); skin_buttonglow(get(name),0.3) );"
	       onout.addevent="if(skin_lockglow === name AND !pressed, skin_buttonglow(null);delete(skin_lockglow); );"
	       onup.addevent="delayedcall(0, if(hovering AND enabled, skin_buttonglow(get(name),0.3); , skin_buttonglow(null);delete(skin_lockglow); ); );"
	       />

	<!-- skin_thumbtext_style - style/textfield for the (optional, skin_settings.thumbs_text) thumbnails texts -->
	<style name="skin_thumbtext_style" type="text" align="bottom" width="100%" y="5" enabled="false" bg="false" bgborder="false" css="calc:skin_settings.design_text_css + ' text-align:center; font-size:10px;'" textshadow="get:skin_settings.design_text_shadow" />

	<!-- skin_hotspotstyle - style for the hotspots -->
	<style name="skin_hotspotstyle" url="vtourskin_hotspot.png" edge="top" distorted="true"
	       tooltip=""
	       linkedscene=""
	       linkedscene_lookat=""
	       onclick="skin_hotspotstyle_click();"
	       depth="1000"
	       scale="0.5"
	       onover.addevent="tween(scale,0.55);"
	       onout.addevent="tween(scale,0.5);"
	       onloaded.addevent="skin_hotspotstyle_setup();"
	       />

	<style name="skin_hotspotstyle2" url="vtourskin_hotspot.png" scale="0.7" edge="top" distorted="true"
	       tooltip=""
	       linkedscene=""
	       linkedscene_lookat=""
	       onclick="skin_hotspotstyle_click();"
	       onover="tween(scale,0.8);"
	       onout="tween(scale,0.85);"
	       onloaded="if(linkedscene AND skin_settings.tooltips_hotspots, copy(tooltip,scene[get(linkedscene)].title); loadstyle(skin_tooltips); );"
	       />

	<action name="skin_hotspotstyle_setup" scope="local">
		if(isvalue(caller.linkedscene) AND skin_settings.tooltips_hotspots,
			copy(caller.tooltip, scene[get(caller.linkedscene)].title);
			caller.loadstyle(skin_tooltips);
		);
	</action>

	<action name="skin_hotspotstyle_click" scope="local">
		if(isvalue(caller.linkedscene),
			copy(hs_linkedscene, caller.linkedscene);
			if(caller.linkedscene_lookat, txtsplit(caller.linkedscene_lookat, ',', hs_lookat_h, hs_lookat_v, hs_lookat_fov); );
			set(caller.enabled, false);
			skin_hidetooltips();
			tween(caller.depth|caller.alpha|caller.oy|caller.rx, 4000|0.0|-50|-60, 0.5, default,
				skin_loadscene(get(hs_linkedscene), get(skin_settings.loadscene_blend));
				if(hs_lookat_h !== null, skin_lookat(get(hs_lookat_h), get(hs_lookat_v), get(hs_lookat_fov)); );
				skin_updatescroll();
			);
		);
	</action>
	

	<!-- skin_tooltip - style for the thumb, hotspot and mapspot tooltips -->
	<style name="skin_tooltips"
	       onover.addevent.mouse="copy(layer[skin_tooltip].html, tooltip);
	                     set(layer[skin_tooltip].visible, calc(webvr.isenabled ? false : true));
	                     tween(layer[skin_tooltip].alpha, 1.0, 0.1);
	                     asyncloop(hovering, copy(layer[skin_tooltip].x,mouse.stagex); copy(layer[skin_tooltip].y,mouse.stagey); );"
	       onout.addevent.mouse="tween(layer[skin_tooltip].alpha, 0.0, 0.1, default, set(layer[skin_tooltip].visible,false), copy(layer[skin_tooltip].x,mouse.stagex); copy(layer[skin_tooltip].y,mouse.stagey); );"
	       />


	<!-- the tooltip textfield -->
	<layer name="skin_tooltip" keep="true"
	       type="text"
	       parent="STAGE"
	       visible="false" alpha="0" enabled="false" zorder="2"
	       align="lefttop" edge="bottom" oy="-2" width="200"
	       bg="false"
	       textshadow="get:skin_settings.design_text_shadow" textshadowrange="6.0" textshadowangle="90" textshadowcolor="0x000000" textshadowalpha="1.0"
	       css="calc:skin_settings.design_text_css + ' text-align:center; font-size:16px;'"
	       html=""
	       />


	<!-- skin layout -->
	<!-- <layer name="skin_layer" keep="true" type="container" align="top" width="get:skin_settings.layout_width" maxwidth="get:skin_settings.layout_maxwidth" height="100%" maskchildren="true" visible="false" bgcapture="false" zorder="1">
		<layer name="skin_scroll_window" type="container" align="bottom" width="100%" height="100%" x="0" y="calc:skin_settings.controlbar_offset + skin_settings.controlbar_height - skin_settings.controlbar_overlap" maskchildren="true" onloaded="skin_calc_opened_closed();" zorder="1">
			<layer name="skin_scroll_layer" type="container" align="bottom" width="get:skin_settings.controlbar_width" height="100%" x="0" y="200" y_offset="get:skin_settings.controlbar_overlap" accuracy="1" bgalpha="get:skin_settings.design_bgalpha" bgcolor="get:skin_settings.design_bgcolor" bgborder="get:skin_settings.design_bgborder" bgroundedge="get:skin_settings.design_bgroundedge" bgshadow="get:skin_settings.design_bgshadow">
				<layer name="skin_title" type="text" align="lefttop" edge="leftbottom" x="4" y="0" zorder="4" enabled="false" bg="false" css="calc:skin_settings.design_text_css + ' text-align:left; font-style:italic; font-size:12px;'" textshadow="get:skin_settings.design_text_shadow" visible="false" onautosized="skin_video_updateseekbarwidth();" />
				<layer name="skin_video_controls" type="container" align="lefttop" edge="leftbottom" width="100%" height="18" visible="false">
					<layer name="skin_video_seekbar_container" type="container" align="lefttop" width="100%" height="100%" bgcapture="true" ondown="skin_video_ondownseeking();" >
						<layer name="skin_video_seekbar" type="container" bgcolor="0xFFFFFF" bgalpha="0.25" align="center" width="100%" height="2">
							<layer name="skin_video_loadbar" type="container" bgcolor="0xFFFFFF" bgalpha="0.5" align="left" width="0" height="2" />
							<layer name="skin_video_seekpos" type="container" bgcolor="0xFFFFFF" bgalpha="1.0" align="left" edge="center" x="0" bgroundedge="8" width="10" height="10" />
						</layer>
					</layer>
					<layer name="skin_video_time" type="text" align="rightbottom" x="4" enabled="false" bg="false" css="calc:skin_settings.design_text_css + ' text-align:left; font-style:italic; font-size:12px;'" textshadow="get:skin_settings.design_text_shadow" html="0:00 / 0:00" />
				</layer>
				<layer name="skin_scroll_container" type="container" align="lefttop" width="100%" height="100%" x="0" y="0" bgroundedge="get:skin_settings.design_bgroundedge" maskchildren="true">
					<layer name="skin_thumbs_container" type="container" align="lefttop" width="100%" height="100%" visible="false">
						<layer name="skin_thumbs_scrollleft"  style="skin_base|skin_glow" crop="0|64|64|64"  align="lefttop"  edge="left"  x="5" y="50" scale="0.5" zorder="2" alpha="1.0" ondown="asyncloop(pressed, layer[skin_thumbs].scrollby(+2,0));" visible="false" />
						<layer name="skin_thumbs_scrollright" style="skin_base|skin_glow" crop="64|64|64|64" align="righttop" edge="right" x="5" y="50" scale="0.5" zorder="2" alpha="1.0" ondown="asyncloop(pressed, layer[skin_thumbs].scrollby(-2,0));" visible="false" />
						<layer name="skin_thumbs_scrollindicator" type="container" bgcolor="0xFFFFFF" bgalpha="0.25" align="lefttop" width="0" y="100" height="2" visible="false" enabled="false" />
						<layer name="skin_thumbs" state="closed" url.flash="%VIEWER%/plugins/scrollarea.swf" url.html5="%VIEWER%/plugins/scrollarea.js" direction="h" align="top" width="100%" height="100" zorder="1" onloaded="skin_updatescroll();" onscroll="skin_updatethumbscroll();" />
					</layer>
					<layer name="skin_map_container" type="container" align="leftop" width="100%" height="100%" bgroundedge="get:skin_settings.design_bgroundedge" maskchildren="true">
						<layer name="skin_map" state="closed" url="" visible="false" align="lefttop" width="100%" height="50%" x="0" y="0" zorder="1" lat="0" lng="0" zoom="10" bgalpha="0" maptype="satellite" onmapready="skin_addmapspots();">
							<maptypecontrol visible="true" align="righttop" x="5" y="5" buttonalign="v" scale.mobile="1.5" />
							<radar visible="false" headingoffset="0" />
							<spotstyle name="DEFAULT" url="vtourskin_mapspot.png" activeurl="vtourskin_mapspotactive.png" edge="bottom" x="-5" y="-8" scale="0.5" />
							<layer name="skin_map_zoom_in"  style="skin_base" visible="get:skin_settings.maps_zoombuttons" crop="9|512|46|64"  align="right" x="0" y="-40" zorder="2" ondown="layer[skin_map].zoomin();  skin_buttonglow(get(name));" onup="skin_buttonglow(null);" />
							<layer name="skin_map_zoom_out" style="skin_base" visible="get:skin_settings.maps_zoombuttons" crop="73|512|46|64" align="right" x="0" y="+40" zorder="2" ondown="layer[skin_map].zoomout(); skin_buttonglow(get(name));" onup="skin_buttonglow(null);" />
						</layer>
					</layer>
				</layer>
			</layer>
		</layer>

		<layer name="skin_splitter_bottom" type="container" align="bottom" width="100%" height="calc:skin_settings.controlbar_offset + skin_settings.controlbar_height - skin_settings.controlbar_overlap" y="0" maskchildren="true" onloaded="skin_calc_opened_closed();" zorder="2">
			<layer name="skin_control_bar_bg" type="container" align="bottom" width="get:skin_settings.controlbar_width" height="calc:skin_settings.controlbar_height + skin_settings.controlbar_overlap" x="0" y="get:skin_settings.controlbar_offset" bgcolor="get:skin_settings.design_bgcolor" bgalpha="get:skin_settings.design_bgalpha" bgborder="get:skin_settings.design_bgborder" bgroundedge="get:skin_settings.design_bgroundedge" bgshadow="get:skin_settings.design_bgshadow" />
		</layer>

		<layer name="skin_control_bar" type="container" align="bottom" width="get:skin_settings.controlbar_width" height="calc:skin_settings.controlbar_height" x="0" y="get:skin_settings.controlbar_offset" onloaded="skin_calc_opened_closed();" zorder="3">
			<layer name="skin_control_bar_buttons" type="container" align="leftbottom" width="100%" height="get:skin_settings.controlbar_height">
				<layer name="skin_btn_prev"      style="skin_base|skin_glow" crop="0|64|64|64"   align="left"        x="5"    y="0"  scale="0.5" alpha="0.5"  onclick="if(skin_settings.thumbs_loop, skin_nextscene_loop(-1), skin_nextscene(-1) );" />
				<layer name="skin_btn_thumbs"    style="skin_base|skin_glow" crop="0|128|64|64"  align="left"        x="50"   y="0"  scale="0.5" ondown="skin_showmap(false); skin_showthumbs();" />
				<layer name="skin_btn_map"       style="skin_base|skin_glow" crop="64|128|64|64" align="left"        x="90"   y="0"  scale="0.5" ondown="skin_showthumbs(false); skin_showmap();" visible="false" />
				<layer name="skin_btn_navi" type="container" align="center" x="0" width="240" height="32">
					<layer name="skin_btn_left"  style="skin_base|skin_glow" crop="0|192|64|64"  align="center"      x="-100" y="0"  scale="0.5" ondown="set(hlookat_moveforce,-1);" onup="set(hlookat_moveforce,0);" />
					<layer name="skin_btn_right" style="skin_base|skin_glow" crop="64|192|64|64" align="center"      x="-60"  y="0"  scale="0.5" ondown="set(hlookat_moveforce,+1);" onup="set(hlookat_moveforce,0);" />
					<layer name="skin_btn_up"    style="skin_base|skin_glow" crop="0|256|64|64"  align="center"      x="-20"  y="0"  scale="0.5" ondown="set(vlookat_moveforce,-1);" onup="set(vlookat_moveforce,0);" />
					<layer name="skin_btn_down"  style="skin_base|skin_glow" crop="64|256|64|64" align="center"      x="+20"  y="0"  scale="0.5" ondown="set(vlookat_moveforce,+1);" onup="set(vlookat_moveforce,0);" />
					<layer name="skin_btn_in"    style="skin_base|skin_glow" crop="0|320|64|64"  align="center"      x="+60"  y="0"  scale="0.5" ondown="set(fov_moveforce,-1);"     onup="set(fov_moveforce,0);" />
					<layer name="skin_btn_out"   style="skin_base|skin_glow" crop="64|320|64|64" align="center"      x="+100" y="0"  scale="0.5" ondown="set(fov_moveforce,+1);"     onup="set(fov_moveforce,0);" />
				</layer>
				<layer name="skin_btn_gyro"      style="skin_base|skin_glow" crop="0|384|64|64"  align="center"      x="+140" y="0"  scale="0.5" onclick="switch(plugin[skin_gyro].enabled); if(plugin[skin_gyro].enabled, skin_showmap(false));" visible="false" devices="html5" />
				<layer name="skin_btn_vr"        style="skin_base|skin_glow" crop="0|0|80|64"    align="center"      x="+146" y="0"  scale="0.5" onclick="webvr.enterVR();" visible="false" />
				<layer name="skin_btn_fs"        style="skin_base|skin_glow" crop="0|576|64|64"  align="right"       x="90"   y="0"  scale="0.5" onclick="switch(fullscreen);" devices="fullscreensupport" />
				<layer name="skin_btn_hide"      style="skin_base|skin_glow" crop="0|448|64|64"  align="right"       x="50"   y="0"  scale="0.5" onclick="skin_hideskin()" />
				<layer name="skin_btn_show" type="container" bgcapture="true" align="bottom" width="100%" height="get:skin_settings.controlbar_height" y="calc:skin_settings.controlbar_height - skin_settings.controlbar_offset_closed" onclick="skin_showskin()" onhover="tween(alpha,1.0);" onout="tween(alpha,0.25);" ondown.touch="onhover();" onup.touch="onout();" visible="false" capture="false" alpha="0.0">
					<layer name="skin_btn_show_icon" style="skin_base" crop="64|448|64|64" scale="0.5" align="bottom" y="2" enabled="false" />
				</layer>
				<layer name="skin_btn_next"      style="skin_base|skin_glow" crop="64|64|64|64"  align="right"       x="5"    y="0"   scale="0.5" alpha="0.5"  onclick="if(skin_settings.thumbs_loop, skin_nextscene_loop(+1), skin_nextscene(+1) );" />
				</layer>
			</layer>

		<layer name="skin_loadingtext" type="text" align="center" x="5" y="-5" html="get:skin_settings.loadingtext" visible="false" bg="false" enabled="false" css="calc:skin_settings.design_text_css + ' text-align:center; font-style:italic; font-size:22px;'" textshadow="get:skin_settings.design_text_shadow" />
		<layer name="skin_buttonglow"  style="skin_base" crop="64|384|64|64" align="center" x="0" y="1" scale="1.0" alpha="0.0" visible="false" enabled="false" />
		<layer name="skin_thumbborder" type="container" x="get:skin_settings.design_thumbborder_padding" y="get:skin_settings.design_thumbborder_padding" width="calc:skin_settings.thumbs_width - 2*skin_settings.design_thumbborder_padding" height="calc:skin_settings.thumbs_height - 2*skin_settings.design_thumbborder_padding" visible="false" enabled="false" align="lefttop" bgborder="get:skin_settings.design_thumbborder_bgborder" bgroundedge="get:skin_settings.design_thumbborder_bgroundedge" />
	</layer> -->

	<!-- previous/next scene buttons for the hidden skin mode -->
	<layer name="skin_btn_prev_fs" keep="true" type="container" align="lefttop"  x="-50" width="40" height="100%" bgcapture="true" alpha="0.0" enabled="false" capture="false" zorder="2" onclick="skin_nextscene_loop(-1);" onhover="tween(alpha,1.0);" onout="tween(alpha,0.25);" ondown.touch="onhover();" onup.touch="onout();">
		<layer name="skin_btn_prev_fs_icon" style="skin_base" crop="0|64|64|64"  align="center" scale="0.5" enabled="false" />
	</layer>
	<layer name="skin_btn_next_fs" keep="true" type="container" align="righttop" x="-50" width="40" height="100%" bgcapture="true" alpha="0.0" enabled="false" capture="false" zorder="2" onclick="skin_nextscene_loop(+1);" onhover="tween(alpha,1.0);" onout="tween(alpha,0.25);" ondown.touch="onhover();" onup.touch="onout();">
		<layer name="skin_btn_next_fs_icon" style="skin_base" crop="64|64|64|64" align="center" scale="0.5" enabled="false" />
	</layer>


	<!-- gyro plugin -->
	<plugin name="skin_gyro" keep="true" url="" html5_url="%VIEWER%/plugins/gyro2.js" softstart="1.0" desktopsupport="false" enabled="false" onavailable="skin_arrange_buttons();" devices="html5" />


	<!-- skin events -->
	<!-- <events name="skin_events" keep="true"
	        onxmlcomplete="set(events[skin_events].onxmlcomplete, skin_showloading(true); ); skin_showloading(true); skin_startup();"
	        onnewpano="skin_update_scene_infos(); skin_deeplinking_update_url();"
	        onloadcomplete="skin_showloading(false);"
	        onidle="skin_deeplinking_update_url();"
	        onresize="skin_onresize();"
	        onenterfullscreen.fullscreensupport="set(layer[skin_btn_fs].crop, '64|576|64|64');"
	        onexitfullscreen.fullscreensupport="set(layer[skin_btn_fs].crop, '0|576|64|64');"
	        onkeydown="skin_keydown_event();"
	        /> -->


	<!-- skin actions -->
	
	<action name="skin_onstart_loadscene" scope="local" autorun="onstart">
		
		<!-- load first scene -->
		loadscene(calc(skin_settings.deeplinking == true AND isset(startscene) ? startscene : 0), null, MERGE);
	
		<!-- set optional deeplinking startup lookat -->
		if(skin_settings.deeplinking == true AND isset(startlookat),
			txtsplit(startlookat, ',', hlookat,vlookat,fov,distortion,architectural);
			lookat(get(hlookat),get(vlookat),get(fov),get(distortion),get(architectural));
		);

	</action>
	
	
	<action name="skin_startup" scope="local">
		
		<!-- apply skin settings on startup -->
		if(skin_settings.thumbs,
			if(skin_settings.thumbs_opened,
				set(layer[skin_thumbs].state, 'opened');
				set(layer[skin_thumbs_container].visible, true);
			);
			copy(layer[skin_thumbs].draggable, skin_settings.thumbs_dragging);
			if(skin_settings.thumbs_onhoverscrolling AND device.mouse,
				set(layer[skin_thumbs].draggable, false);
				set(layer[skin_thumbs].onhover_autoscrolling, true);
			);
		);

		if(skin_settings.gyro AND !device.desktop AND device.html5,
			copy(plugin[skin_gyro].url, plugin[skin_gyro].html5_url);
		);

		if(skin_settings.maps == true,
			set(layer[skin_btn_map].visible, true);

			if (skin_settings.maps_loadonfirstuse == false,
				skin_load_maps_plugin();
			);
		);

		if(skin_settings.littleplanetintro AND !global.startlookat AND (device.webgl OR device.flash),
			skin_setup_littleplanetintro();
		);

		skin_addthumbs();
		skin_onresize();
		skin_updatescroll();

		set(layer[skin_layer].visible, true);
	</action>
	

	<action name="skin_load_maps_plugin">
		if (!layer[skin_map].url,
			if(device.flash,
				copy(layer[skin_map].key, skin_settings.maps_bing_api_key);
				set(layer[skin_map].url, '%VIEWER%/plugins/bingmaps.swf');
			  ,
				if(skin_settings.maps_type == 'bing',
					copy(layer[skin_map].key, skin_settings.maps_bing_api_key);
					set(layer[skin_map].url, '%VIEWER%/plugins/bingmaps.js');
				  ,
				 	copy(layer[skin_map].key, skin_settings.maps_google_api_key);
					set(layer[skin_map].url, '%VIEWER%/plugins/googlemaps.js');
				);
			);
		);
	</action>


	<action name="skin_addthumbs" scope="local">
		
		<!-- build a global array of visible scene thumbnails -->
		def(global.thumbarray, array);
		set(thumbcount, 0);
		for(set(i,0), i LT scene.count, inc(i),
			if(isvalue(scene[get(i)].thumburl) AND scene[get(i)].skipthumb != true,
				<!-- link thumbarray[i1] to scene[i2] -->
				set(thumbarray[get(thumbcount)], get(scene[get(i)]));
				set(scene[get(i)].sceneindex, get(i));
				set(scene[get(i)].thumbindex, get(thumbcount));
				inc(thumbcount);
			);
		);
		
		if(skin_settings.thumbs == false,
			set(layer[skin_btn_thumbs].visible,false);
		  ,
			copy(thumbwidth, skin_settings.thumbs_width);
			copy(thumbheight, skin_settings.thumbs_height);
			copy(thumbpadding, skin_settings.thumbs_padding);
			copy(thumbcrop, skin_settings.thumbs_crop);

			calc(thumbxoffset, thumbwidth + thumbpadding);
			calc(thumbxcenter, thumbxoffset * 0.5);
			calc(thumbbarwidth, thumbxoffset * thumbcount + thumbpadding);
			calc(thumbbarheight, thumbpadding + thumbheight + thumbpadding);

			if(skin_settings.thumbs_scrollindicator,
				copy(layer[skin_thumbs_scrollindicator].y, thumbbarheight);
				add(thumbbarheight, layer[skin_thumbs_scrollindicator].height);
			);
			
			set(layer[skin_thumbs], width=get(thumbbarwidth), height=get(thumbbarheight) );

			calc(layer[skin_thumbs_scrollleft].y, thumbbarheight * 0.5);
			calc(layer[skin_thumbs_scrollright].y, thumbbarheight * 0.5);

			for(set(i,0), i LT thumbcount, inc(i),
			
				copy(currentscene, thumbarray[get(i)]);

				calc(thumbname, 'skin_thumb_' + i);
				addlayer(get(thumbname));

				set(layer[get(thumbname)],
					url=get(currentscene.thumburl),
					keep=true,
					parent='skin_thumbs',
					align='lefttop',
					crop=get(thumbcrop),
					width=get(thumbwidth),
					height=get(thumbheight),
					x=calc(thumbpadding + i*thumbxoffset),
					y=get(thumbpadding),
					linkedscene=get(currentscene.name),
					onclick='copy(layer[skin_thumbborder].parent, name); skin_loadscene(get(linkedscene),get(skin_settings.loadscene_blend));'
				);
					
				set(currentscene, 
					thumbx=calc(thumbpadding + i*thumbxoffset + thumbxcenter),
					thumby=get(thumbpadding)
				);
					
				if(skin_settings.tooltips_thumbs,
					set(layer[get(thumbname)].tooltip, get(currentscene.title) );
					layer[get(thumbname)].loadstyle(skin_tooltips);
				);
					
				if(skin_settings.thumbs_text,
					calc(thumbtext, 'skin_thumbtext_' + i);
					addlayer(get(thumbtext));
					layer[get(thumbtext)].loadstyle(skin_thumbtext_style);
					set(layer[get(thumbtext)], keep=true, parent=get(thumbname), html=get(currentscene.title) );
				);
			);
			
			if(thumbcount == 1,
				set(layer[skin_thumbs].align, 'lefttop');
			);
		);
	</action>


	<!-- called from bing- or google-maps plugin onmapready event -->
	<action name="skin_addmapspots" scope="local">
		for(set(i,0), i LT scene.count, inc(i),
			if(scene[get(i)].lat,
				calc(spotname, 'spot' + i);
				calc(spotclickevent, 'skin_hidetooltips(); activatespot(' + spotname + '); skin_loadscene(' + scene[get(i)].name + ',get(skin_settings.loadscene_blend)); skin_updatescroll(); delayedcall(0.5,skin_showmap(false));' );
				copy(scene[get(i)].mapspotname, spotname);
				caller.addspot(get(spotname), get(scene[get(i)].lat), get(scene[get(i)].lng), get(scene[get(i)].heading), false, get(spotclickevent), null);
				if(skin_settings.tooltips_mapspots,
					set(layer[skin_map].spot[get(spotname)].tooltip, get(scene[get(i)].title) );
					txtadd(layer[skin_map].spot[get(spotname)].onover, 'set(hovering,true);',  get(style[skin_tooltips].onover:addevent) );
					txtadd(layer[skin_map].spot[get(spotname)].onout,  'set(hovering,false);', get(style[skin_tooltips].onout:addevent)  );
				);
			);
		);

		caller.activatespot( calc(xml.scene != null ? scene[get(xml.scene)].mapspotname : 'spot0') );
		caller.zoomToSpotsExtent();
	</action>


	<action name="skin_setup_littleplanetintro" scope="local">
		skin_hideskin(instant);
		set(global.lpinfo, scene=get(xml.scene), hlookat=get(view.hlookat), vlookat=get(view.vlookat), fov=get(view.fov), fovmax=get(view.fovmax), limitview=get(view.limitview) );
		set(view, fovmax=170, limitview=lookto, vlookatmin=90, vlookatmax=90);
		lookat(calc(global.lpinfo.hlookat - 180), 90, 150, 1, 0, 0);
		set(events[lp_events].onloadcomplete,
			delayedcall(0.5,
				if(lpinfo.scene === xml.scene,
					set(control.usercontrol, off);
					set(view, limitview=get(lpinfo.limitview), vlookatmin=null, view.vlookatmax=null);
					tween(view.hlookat|view.vlookat|view.fov|view.distortion, calc('' + lpinfo.hlookat + '|' + lpinfo.vlookat + '|' + lpinfo.fov + '|' + 0.0), 3.0, easeOutQuad);
					delayedcall(3.0,
						set(control.usercontrol, all);
						tween(view.fovmax, get(lpinfo.fovmax));
						skin_deeplinking_update_url();
						delete(global.lpinfo);
						skin_showskin();
						if(skin_settings.thumbs AND skin_settings.thumbs_opened, skin_showthumbs() );
					);
				  ,
					delete(global.lpinfo);
				);
			);
		);
	</action>
	
	
	<action name="skin_lookat" scope="local" args="h, v, fov">
		if(webvr.isenabled,
			<!-- adjust the VR prev/next hotspots for the view change -->
			calc(hlookat_offset, h - view.hlookat);
			add(hotspot[skin_webvr_prev_scene].ath, hlookat_offset);
			add(hotspot[skin_webvr_next_scene].ath, hlookat_offset);
		);
		if(plugin[skin_gyro].isavailable AND plugin[skin_gyro].enabled,
			<!-- reset the gyro tracking -->
			plugin[skin_gyro].resetsensor(get(h));
		);
		<!-- change the view -->
		lookat(get(h), get(v), get(fov));
	</action>


	<action name="skin_onresize" scope="local">
		mul(mh, area.pixelheight, -1);
		if(layer[skin_thumbs].state == 'opened', add(mh,layer[skin_thumbs].height); );
		if(layer[skin_map].state    == 'opened', sub(hh,area.pixelheight,skin_settings.controlbar_offset); sub(hh,layer[skin_control_bar].height); sub(hh,32); add(mh,hh); add(mh,skin_settings.controlbar_overlap); sub(mh, layer[skin_scroll_layer].y_offset); copy(layer[skin_map].height, hh); );
		add(mh, layer[skin_scroll_layer].y_offset);
		set(layer[skin_scroll_layer].y, get(mh));
		if(display.safearea_inset, calc(layer[skin_btn_show].y, skin_settings.controlbar_height - skin_settings.controlbar_offset_closed - (display.safearea_inset.b LT 0 ? display.safearea_inset.b : 0)); );
		skin_video_updateseekbarwidth();
		skin_arrange_buttons();
	</action>


	<!-- determine the visibility of the buttons and calculate their positions -->
	<action name="skin_arrange_buttons" scope="local">
		calc(show_selbuttons, scene.count GT 1);
		calc(show_thumbutton, skin_settings.thumbs == true);
		calc(show_mapbutton,  skin_settings.maps == true);
		calc(show_gyrobutton, plugin[skin_gyro].isavailable == true AND (view.vlookatrange == 180 OR global.lpinfo.scene === xml.scene));
		calc(show_vrbutton,   webvr.isavailable == true);
		calc(show_fsbutton,   device.fullscreensupport == true);

		set(lpos,6);
		set(cpos,0);
		if(show_gyrobutton, dec(cpos,20));
		if(show_vrbutton OR plugin[webvr].mobilevr_fake_support == true, dec(cpos,24));
		set(rpos,6);

		calc(show_dirbuttons, !device.mobile AND ((area.pixelwidth + 2*cpos) GT 520) );

		copy(layer[skin_btn_navi].visible, show_dirbuttons);

		copy(layer[skin_btn_prev].visible, show_selbuttons);
		copy(layer[skin_btn_next].visible, show_selbuttons);
		if(show_selbuttons, inc(lpos,44); inc(rpos,44); );

		copy(layer[skin_btn_thumbs].visible, show_thumbutton);
		copy(layer[skin_btn_thumbs].x, lpos);
		if(show_thumbutton, inc(lpos,40));

		copy(layer[skin_btn_map].visible, show_mapbutton);
		copy(layer[skin_btn_map].x, lpos);
		if(show_mapbutton, inc(lpos,40));

		if(show_dirbuttons,
			copy(layer[skin_btn_navi].x, cpos);
			inc(cpos,140);

			set(layer[skin_btn_gyro].align, center);
			copy(layer[skin_btn_gyro].visible, show_gyrobutton);
			copy(layer[skin_btn_gyro].x, cpos);
			if(show_gyrobutton, inc(cpos,48));

			set(layer[skin_btn_vr].align, center);
			copy(layer[skin_btn_vr].visible, show_vrbutton);
			copy(layer[skin_btn_vr].x, cpos);
			if(show_vrbutton, inc(cpos,80));
		  ,
			set(layer[skin_btn_gyro].align, left);
			copy(layer[skin_btn_gyro].visible, show_gyrobutton);
			copy(layer[skin_btn_gyro].x, lpos);
			if(show_gyrobutton, inc(lpos,40));

			set(layer[skin_btn_vr].align, left);
			copy(layer[skin_btn_vr].visible, show_vrbutton);
			copy(layer[skin_btn_vr].x, lpos);
			if(show_vrbutton, inc(lpos,80));
		);

		copy(layer[skin_btn_hide].x, rpos);
		inc(rpos,40);

		copy(layer[skin_btn_fs].visible, show_fsbutton);
		copy(layer[skin_btn_fs].x, rpos);
		if(show_fsbutton, inc(rpos,40));
	</action>


	<action name="skin_updatescroll" scope="local">
		if(layer[skin_thumbs].loaded,
			set(cursceneindex, 0);
			if(xml.scene, copy(cursceneindex, scene[get(xml.scene)].index));
			layer[skin_thumbs].setcenter(get(scene[get(cursceneindex)].thumbx), get(scene[get(cursceneindex)].thumby));
		);
	</action>


	<action name="skin_updatethumbscroll" scope="local">
		copy(padding,skin_settings.thumbs_padding);

		if(skin_settings.thumbs_scrollbuttons,
			if(caller.loverflow GT 0, set(layer[skin_thumbs_scrollleft].visible,true),  set(layer[skin_thumbs_scrollleft].visible,false) );
			if(caller.roverflow GT 0, set(layer[skin_thumbs_scrollright].visible,true), set(layer[skin_thumbs_scrollright].visible,false) );
		);

		if(skin_settings.thumbs_scrollindicator,
			if(caller.woverflow GT 0,
				set(layer[skin_thumbs_scrollindicator].visible, true);
				sub(iw,caller.pixelwidth,caller.woverflow);
				div(pw,iw,caller.pixelwidth);
				div(px,caller.loverflow,caller.woverflow);
				mul(pw,iw);
				copy(layer[skin_thumbs_scrollindicator].width, pw);
				sub(iw,pw);
				sub(iw,padding);
				sub(iw,padding);
				mul(px,iw);
				add(px,padding);
				copy(layer[skin_thumbs_scrollindicator].x, px);
			  ,
				set(layer[skin_thumbs_scrollindicator].visible, false);
			);
		);
	</action>


	<action name="skin_update_scene_infos" scope="local">
		if(xml.scene !== null AND scene[get(xml.scene)].index GE 0,

			if(skin_settings.title,
				if(global.title, calc(layer[skin_title].html, global.title + ' - ' + scene[get(xml.scene)].title); , copy(layer[skin_title].html, scene[get(xml.scene)].title ); );
				delayedcall(0.1, set(layer[skin_title].visible,true) );
			);

			if(skin_settings.thumbs_loop == false,
				if(scene[get(xml.scene)].index GT 0,
					set(layer[skin_btn_prev], enabled=true, alpha=1.0);
				  ,
					set(layer[skin_btn_prev], enabled=false, alpha=0.3);
				);

				sub(lastsceneindex, scene.count, 1);
				if(scene[get(xml.scene)].index LT lastsceneindex,
					set(layer[skin_btn_next], enabled=true, alpha=1.0);
				  ,
					set(layer[skin_btn_next], enabled=false, alpha=0.3);
				);
			  ,
				if(scene.count GT 1,
					set(layer[skin_btn_prev], enabled=true, alpha=1.0);
					set(layer[skin_btn_next], enabled=true, alpha=1.0);
				  ,
					set(layer[skin_btn_prev], enabled=false, alpha=0.3);
					set(layer[skin_btn_next], enabled=false, alpha=0.3);
				);
			);

			if(scene.count GT 1,
				set(layer[skin_btn_prev_fs].visible, true);
				set(layer[skin_btn_next_fs].visible, true);
			  ,
				set(layer[skin_btn_prev_fs].visible, false);
				set(layer[skin_btn_next_fs].visible, false);
			);

			calc(parentname, 'skin_thumb_' + scene[get(xml.scene)].thumbindex);
			if(scene[get(xml.scene)].thumburl AND scene[get(xml.scene)].skipthumb != true AND layer[get(parentname)],
				set(layer[skin_thumbborder], parent=get(parentname), visible=true);
			  ,
				set(layer[skin_thumbborder].visible, false);
			);

			if(scene[get(xml.scene)].mapspotname,
				layer[skin_map].activatespot(get(scene[get(xml.scene)].mapspotname));
				layer[skin_map].pantospot(get(scene[get(xml.scene)].mapspotname));
			);

			if(plugin[skin_gyro].isavailable == true AND (view.vlookatrange == 180 OR global.lpinfo.scene === xml.scene),
				set(layer[skin_btn_gyro].visible, true);
			  ,
				set(layer[skin_btn_gyro].visible, false)
			);
			
			if(scene[get(xml.scene)].isvideopano AND plugin[video] !== null,
				skin_video_addcontrols();
			  ,
				skin_video_removecontrols();
			);
		);
	</action>
	

	<action name="skin_gotoscene" scope="local" args="newscene">
		if(scene[get(newscene)],
			copy(cursceneindex, scene[get(xml.scene)].index);
			copy(newsceneindex, scene[get(newscene)].index);
			skin_loadscene(get(newsceneindex), calc(newsceneindex LT cursceneindex ? skin_settings.loadscene_blend_prev : (newsceneindex GT cursceneindex ? skin_settings.loadscene_blend_next : skin_settings.loadscene_blend)) );
		);
	</action>


	<action name="skin_nextscene" scope="local" args="indexadd">
		set(newscenename, null);
		if(isset(scene[get(xml.scene)].thumbindex),
			add(newsceneindex, scene[get(xml.scene)].thumbindex, indexadd);
			if(newsceneindex GE 0 AND newsceneindex LT thumbarray.length,
				set(newscenename, get(thumbarray[get(newsceneindex)].name));
			);
		  ,
			add(newsceneindex, scene[get(xml.scene)].index, indexadd);
			if(newsceneindex GE 0 AND newsceneindex LT scene.count,
				set(newscenename, get(scene[get(newsceneindex)].name));
			);
		);
		if(newscenename != null,
			skin_loadscene(get(newscenename), calc(indexadd LT 0 ? skin_settings.loadscene_blend_prev : skin_settings.loadscene_blend_next));
		);
	</action>


	<action name="skin_nextscene_loop" scope="local" args="indexadd">
		set(newscenename, null);
		if(isset(scene[get(xml.scene)].thumbindex),
			sub(lastsceneindex, thumbarray.length, 1);
			add(newsceneindex, scene[get(xml.scene)].thumbindex, indexadd);
			if(newsceneindex LT 0, copy(newsceneindex,lastsceneindex));
			if(newsceneindex GT lastsceneindex, set(newsceneindex,0));
			set(newscenename, get(thumbarray[get(newsceneindex)].name));
		  ,
			add(newsceneindex, scene[get(xml.scene)].index, indexadd);
			sub(lastsceneindex, scene.count, 1);
			if(newsceneindex LT 0, copy(newsceneindex,lastsceneindex));
			if(newsceneindex GT lastsceneindex, set(newsceneindex,0));
			set(newscenename, get(scene[get(newsceneindex)].name));
		);
		if(newscenename != null,
			skin_loadscene(get(newscenename), calc(indexadd LT 0 ? skin_settings.loadscene_blend_prev : skin_settings.loadscene_blend_next));
		);
	</action>


	<action name="skin_loadscene" scope="local" args="newscenenameorindex, blendmode">
		if(webvr.isenabled AND scene.count GT 1,
			set(hotspot[skin_webvr_prev_scene].visible, false);
			set(hotspot[skin_webvr_next_scene].visible, false);
		);

		calc(parentname, 'skin_thumb_' + scene[get(newscenenameorindex)].thumbindex);
		if(scene[get(newscenenameorindex)].thumburl AND scene[get(newscenenameorindex)].skipthumb != true AND layer[get(parentname)],
			set(layer[skin_thumbborder], parent=get(parentname), visible=true);
		  ,
			set(layer[skin_thumbborder].visible, false);
		);
		
		layer[skin_thumbs].scrolltocenter(get(scene[get(newscenenameorindex)].thumbx), get(scene[get(newscenenameorindex)].thumby));
		loadscene(get(scene[get(newscenenameorindex)].name), null, get(skin_settings.loadscene_flags), get(blendmode));
	</action>


	<action name="skin_showloading" scope="private:SKINLOADINGCHECK" args="state">
		if(state == true AND global.display.stereo == false,
			<!-- start loading -->
			set(loadingstate, 1);
			delayedcall(2.0,
				if(loadingstate == 1,
					<!-- after 2.0 seconds still not loaded? => show the loading text -->
					set(global.layer[skin_loadingtext].visible, true);
				);
			);
		  ,
			<!-- stop loading -->
			set(loadingstate, 2);
			set(global.layer[skin_loadingtext].visible, false);
		);
	</action>


	<action name="skin_hidetooltips">
		set(layer[skin_tooltip], alpha=0.0, visible=false);
	</action>


	<action name="skin_buttonglow" scope="local" args="layertoglow, strength">
		if(layertoglow != null,
			if(strength == null, set(strength,0.7));
			set(layer[skin_buttonglow], parent=get(layertoglow), visible=true);
			tween(layer[skin_buttonglow].alpha, get(strength), 0.07);
		  ,
			tween(layer[skin_buttonglow].alpha, 0.0, 0.1, default, set(layer[skin_buttonglow], parent=null, visible=false); );
		);
	</action>


	<action name="skin_calc_opened_closed">
		if(layer[get(name)].y_closed === null,
			set(layer[get(name)].y_opened, get(layer[get(name)].y));
			set(layer[get(name)].y_closed, calc(layer[get(name)].y - skin_settings.controlbar_offset - skin_settings.controlbar_height + skin_settings.controlbar_offset_closed));
		);
	</action>


	<action name="skin_hideskin" scope="local" args="hidetimemode">
		calc(hidetime, hidetimemode == 'instant' ? 0.0 : 0.5);
		
		callwith(layer[skin_scroll_window],   skin_calc_opened_closed() );
		callwith(layer[skin_splitter_bottom], skin_calc_opened_closed() );
		callwith(layer[skin_control_bar],     skin_calc_opened_closed() );

		if(layer[skin_map].state    != 'closed', skin_showmap(false);    if(hidetime GT 0, wait(0.40)); );
		if(layer[skin_thumbs].state != 'closed', skin_showthumbs(false); if(hidetime GT 0, wait(0.25)); );

		tween(layer[skin_scroll_window].y,   get(layer[skin_scroll_window  ].y_closed), get(hidetime));
		tween(layer[skin_splitter_bottom].y, get(layer[skin_splitter_bottom].y_closed), get(hidetime));
		tween(layer[skin_control_bar].y,     get(layer[skin_control_bar    ].y_closed), get(hidetime));

		set(layer[skin_btn_prev_fs].enabled, true);
		set(layer[skin_btn_next_fs].enabled, true);
		tween(layer[skin_btn_prev_fs].x|layer[skin_btn_prev_fs].alpha, 0|0.25, get(hidetime));
		tween(layer[skin_btn_next_fs].x|layer[skin_btn_next_fs].alpha, 0|0.25, get(hidetime));

		if(layer[skin_logo], tween(layer[skin_logo].alpha, 0.0, 0.5, default, set(layer[skin_logo].visible,false)); );

		stopdelayedcall(skin_btn_show_alpha);
		set(layer[skin_btn_show].visible, true);
		delayedcall(skin_btn_show_alpha, get(hidetime), tween(layer[skin_btn_show].alpha, 0.25, 0.25); );
	</action>


	<action name="skin_showskin">
		tween(layer[skin_scroll_window  ].y, get(layer[skin_scroll_window  ].y_opened));
		tween(layer[skin_splitter_bottom].y, get(layer[skin_splitter_bottom].y_opened));
		tween(layer[skin_control_bar    ].y, get(layer[skin_control_bar    ].y_opened));

		set(layer[skin_btn_prev_fs].enabled, false);
		set(layer[skin_btn_next_fs].enabled, false);
		tween(layer[skin_btn_prev_fs].x|layer[skin_btn_prev_fs].alpha, -50|0.0);
		tween(layer[skin_btn_next_fs].x|layer[skin_btn_next_fs].alpha, -50|0.0);

		if(layer[skin_logo], set(layer[skin_logo].visible,true); tween(layer[skin_logo].alpha, 1.0); );

		stopdelayedcall(skin_btn_show_alpha);
		set(layer[skin_btn_show].visible, false);
		delayedcall(skin_btn_show_alpha, 0.25, tween(layer[skin_btn_show].alpha, 0.0, 0.0); );
	</action>


	<action name="skin_showthumbs" scope="local" args="show">
		if(show == null, if(layer[skin_thumbs].state == 'closed', set(show,true), set(show,false)); );
		if(show,
			set(layer[skin_thumbs].state, 'opened');
			tween(layer[skin_thumbs].alpha, 1.0, 0.25);
			tween(layer[skin_scroll_layer].y, calc(-area.pixelheight + layer[skin_thumbs].height + layer[skin_scroll_layer].y_offset), 0.5, easeOutQuint);
			set(layer[skin_thumbs_container].visible, true);
			tween(layer[skin_thumbs_container].alpha, 1.0, 0.25);
			tween(layer[skin_map].alpha, 0.0, 0.25, default, set(layer[skin_map].visible,false));
		  ,
			set(layer[skin_thumbs].state, 'closed');
			tween(layer[skin_thumbs].alpha, 0.0, 0.25, easeOutQuint);
			tween(layer[skin_scroll_layer].y, calc(-area.pixelheight + layer[skin_scroll_layer].y_offset), 0.5, easeOutQuint, set(layer[skin_thumbs_container].visible, false););
		);
	</action>


	<action name="skin_showmap" scope="local" args="show">
		if(show == null, if(layer[skin_map].state == 'closed', set(show,true), set(show,false)); );
		if(show,
			skin_load_maps_plugin();
			tween(layer[skin_thumbs_container].alpha, 0.0, 0.25, default, set(layer[skin_thumbs_container].visible,false));
			set(layer[skin_map].visible, true);
			tween(layer[skin_map].alpha, 1.0, 0.25);
			set(layer[skin_map].state, 'opened');
			calc(hh, area.pixelheight - skin_settings.controlbar_offset - layer[skin_control_bar].height - 32);
			calc(layer[skin_map].height, hh - skin_settings.controlbar_overlap);
			tween(layer[skin_scroll_layer].y, calc(hh - area.pixelheight), 0.5, easeOutQuint);
		  ,
		  	if(layer[skin_map].state != 'closed',
				set(layer[skin_map].state, 'closed');
				tween(layer[skin_map].alpha, 0.0, 0.5, easeOutQuint);
				tween(layer[skin_scroll_layer].y, calc(-area.pixelheight + layer[skin_scroll_layer].y_offset), 0.5, easeOutQuint, set(layer[skin_map].visible,false) );
			);
		);
	</action>


	<action name="skin_keydown_event">
		if(keycode == 33, skin_nextscene_loop(-1) );            	<!-- Page Up   - previous scene -->
		if(keycode == 34, skin_nextscene_loop(+1) );            	<!-- Page Dowm - next scene -->
		if(keycode == 35, skin_gotoscene(calc(scene.count-1)) );	<!-- End       - last scene -->
		if(keycode == 36, skin_gotoscene(0) );                  	<!-- Home/Pos1 - first scene -->
	</action>


	<action name="skin_deeplinking_update_url" scope="local" args="delay">
		if(skin_settings.deeplinking AND (!webvr OR webvr.isenabled === false) AND global.lpinfo === null,
			delayedcall(skin_deeplinking_update, calc(delay == null ? 0.1 : delay), skin_deeplinking_update_url_process() );
		);
	</action>

	<action name="skin_deeplinking_update_url_process" scope="local">
		copy(adr, browser.location);
		indexoftxt(qi, get(adr), '?');
		if(qi GT 0, subtxt(adr, adr, 0, get(qi)));
		copy(si, scene[get(xml.scene)].index);
		copy(h, view.hlookat);
		copy(v, view.vlookat);
		copy(f, view.fov);
		copy(d, view.distortion);
		copy(a, view.architectural);
		clamp(d, 0.0, 1.0);
		clamp(a, 0.0, 1.0);
		set(pp, calc(f LT 10 ? 6 : 2));
		roundval(h, get(pp));
		roundval(v, get(pp));
		roundval(f, get(pp));
		roundval(d, 2);
		roundval(a, 1);
		set(adr, calc(adr + '?startscene=' + si + '&amp;startlookat='+h+','+v+','+f+','+d+','+a+';'));
		js( history.replaceState(null, document.title, get(adr)); );
	</action>


	<!-- reload the scene when there is a special image for VR -->
	<action name="skin_reloadscene_webvr" scope="local">
		delayedcall(0.1,
			if(scene[get(xml.scene)].havevrimage,
				copy(skin_settings.keeplookingdirection_backup, skin_settings.webvr_keeplookingdirection);
				set(skin_settings.webvr_keeplookingdirection, true);
				loadscene(get(xml.scene), null, MERGE|KEEPVIEW|KEEPMOVING|KEEPPLUGINS|KEEPHOTSPOTS, BLEND(0.5));
				copy(skin_settings.webvr_keeplookingdirection, skin_settings.keeplookingdirection_backup);
				delete(skin_settings.keeplookingdirection_backup);
			);
		);
	</action>


	<!-- videopano support - https://krpano.com/plugins/videoplayer/ -->
	<action name="skin_video_addcontrols">
		set(events[skin_events].onclick, skin_video_clickevent() );

		set(plugin[video].onvideoready, skin_video_updatestate() );
		set(plugin[video].onvideoplay, skin_video_updatestate() );
		set(plugin[video].onvideopaused, skin_video_updatestate() );
		set(plugin[video].onvideocomplete, skin_video_updatestate() );

		if(plugin[video].ispaused AND plugin[video].pausedonstart,
			set(layer[skin_video_playpause].state, 'visible');
			set(layer[skin_video_playpause].enabled, true);
			tween(layer[skin_video_playpause].alpha, 1.0);
		);

		delayedcall(skin_video_delayedvisible, 0.25, set(layer[skin_video_controls].visible, true) );

		skin_video_updateseekbarwidth();
		set(layer[skin_video_seekpos].x,0);
		set(layer[skin_video_loadbar].width,0);

		setinterval(skin_video_seek_updates, 0.5, skin_video_updatetime() );
	</action>

	<action name="skin_video_removecontrols">
		stopdelayedcall(skin_video_delayedvisible);

		set(events[skin_events].onclick, null);

		set(layer[skin_video_playpause].alpha, 0.0);
		set(layer[skin_video_controls].visible, false);

		clearinterval(skin_video_seek_updates);
	</action>

	<action name="skin_video_updatetime" scope="local" args="seekpos">
		copy(t1, plugin[video].time);
		copy(t2, plugin[video].totaltime);
		if(seekpos != null, calc(t1, seekpos * t2); );
		div(t1_min, t1, 60);
		mod(t1_sec, t1, 60);
		Math.floor(t1_min);
		Math.floor(t1_sec);
		div(t2_min, t2, 60);
		mod(t2_sec, t2, 60);
		Math.floor(t2_min);
		Math.floor(t2_sec);
		calc(layer[skin_video_time].html, t1_min + ':' + (t1_sec LT 10 ? '0' : '') + t1_sec + ' / ' + t2_min + ':' + (t2_sec LT 10 ? '0' : '') + t2_sec);
		calc(layer[skin_video_seekpos].x, (t1 / t2 * 100) + '%');
		calc(layer[skin_video_loadbar].width, (plugin[video].loadedbytes / plugin[video].totalbytes * 100) + '%');
	</action>

	<action name="skin_video_updateseekbarwidth">
		if(skin_settings.title,
			calc(layer[skin_video_seekbar_container].width, 0 - (32 + layer[skin_title].pixelwidth + layer[skin_video_time].pixelwidth));
			calc(layer[skin_video_seekbar_container].x, layer[skin_title].pixelwidth + 16);
		  ,
			calc(layer[skin_video_seekbar_container].width, 0 - (24 + layer[skin_video_time].pixelwidth));
			set(layer[skin_video_seekbar_container].x, 8);
		);
	</action>

	<action name="skin_video_ondownseeking" scope="local">
		asyncloop(caller.pressed,
			screentolayer(skin_video_seekbar, mouse.stagex,mouse.stagey, lx,ly);
			calc(seekpos, lx / layer[skin_video_seekbar].pixelwidth);
			clamp(seekpos, 0.0, 1.0);
			skin_video_updatetime(get(seekpos));
		  ,
			plugin[video].seek(calc((seekpos * 100) + '%'));
		);
	</action>

	<layer name="skin_video_playpause" keep="true"
	         style="skin_base|skin_glow" crop="0|640|64|64" scale="0.75"
	         align="center" alpha="0.0" autoalpha="true"
	         state="hidden"
	         onclick="skin_video_playpause_click();"
	         />

	<action name="skin_video_updatestate">
		calc(layer[skin_video_playpause].crop, plugin[video].ispaused ? '0|640|64|64' : '64|640|64|64');
		if(plugin[video].iscomplete,
			set(layer[skin_video_playpause].state, 'visible');
			tween(layer[skin_video_playpause].alpha, 1.0);
		);
	</action>

	<action name="skin_video_playpause_click">
		if(plugin[video].ispaused,
			plugin[video].play();
			set(layer[skin_video_playpause].state, 'hidden');
			tween(layer[skin_video_playpause].alpha, 0.0);
		  ,
			plugin[video].pause();
			set(layer[skin_video_playpause].state, 'visible');
			tween(layer[skin_video_playpause].alpha, 1.0);
			delayedcall(autohide_pp, 2.0, set(layer[skin_video_playpause].state,'hidden'); tween(layer[skin_video_playpause].alpha, 0.0); );
		);
	</action>

	<action name="skin_video_clickevent">
		stopdelayedcall(autohide_pp);

		switch(layer[skin_video_playpause].state, 'visible', 'hidden');

		if(layer[skin_video_playpause].state == 'hidden',
			tween(layer[skin_video_playpause].alpha, 0.0);
		  ,
			tween(layer[skin_video_playpause].alpha, 1.0);
			delayedcall(autohide_pp, 2.0, set(layer[skin_video_playpause].state,'hidden'); tween(layer[skin_video_playpause].alpha, 0.0); );
		);
	</action>
	
	
	<!-- autotour/autoplay support -->
	<autorotate enabled="calc:skin_settings.autotour == true"
	            waittime="5.0"
	            accel="0.7"
	            speed="4.0"
	            tofov="80"
	            oneroundrange="360"
	            />
	
	<events name="skin_autotour" keep="true"
		onautorotatestart="if(skin_settings.autotour, skin_autotour_start(); );"
		onautorotatestop="if(skin_settings.autotour, skin_autotour_stop(); );"
		onautorotateoneround="if(skin_settings.autotour, skin_nextscene_loop(+1); );"
		/>
	
	<action name="skin_autotour_start" scope="PRIVATE:skin_autotour">
		copy(loadscene_flags_backup, global.skin_settings.loadscene_flags);
		set(global.skin_settings.loadscene_flags, MERGE|KEEPVIEW|KEEPMOVING|PRELOAD);
		copy(loadscene_blend_next_backup, global.skin_settings.loadscene_blend_next);
		set(global.skin_settings.loadscene_blend_next, SLIDEBLEND(2.0, 0, 0.75, linear) );
	</action>
	
	<action name="skin_autotour_stop" scope="PRIVATE:skin_autotour">
		copy(global.skin_settings.loadscene_flags, loadscene_flags_backup);
		copy(global.skin_settings.loadscene_blend_next, loadscene_blend_next_backup);
	</action>


	<!-- context menu - https://krpano.com/docu/xml/#contextmenu -->
	<contextmenu fullscreen="false" versioninfo="false">
		<!-- <item name="kr" caption="KRPANO"     />
		<item name="fs" caption="FULLSCREEN" />
		<item name="cc" caption="Change Controlmode" onclick="skin_changecontrolmode();"  separator="above" />
		<item name="nv" caption="Normal View"        onclick="skin_view_normal();"        showif="view.vlookatrange == 180" separator="above"     />
		<item name="fv" caption="Fisheye View"       onclick="skin_view_fisheye();"       showif="view.vlookatrange == 180" devices="flash|webgl" />
		<item name="sv" caption="Stereographic View" onclick="skin_view_stereographic();" showif="view.vlookatrange == 180" devices="flash|webgl" />
		<item name="av" caption="Architectural View" onclick="skin_view_architectural();" showif="view.vlookatrange == 180"                       />
		<item name="pv" caption="Pannini View"       onclick="skin_view_pannini();"       showif="view.vlookatrange == 180" devices="flash|webgl" />
		<item name="lp" caption="Little Planet View" onclick="skin_view_littleplanet();"  showif="view.vlookatrange == 180" devices="flash|webgl" />
		<item name="sa" caption="Start Autotour"     onclick="autorotate.start();" separator="both" showif="autorotate.isrotating == false" visible="calc:skin_settings.autotour == true" />
		<item name="ta" caption="Stop Autotour"      onclick="autorotate.stop();"  separator="both" showif="autorotate.isrotating == true"  visible="calc:skin_settings.autotour == true" /> -->
	</contextmenu>


	<action name="skin_changecontrolmode">
		if(device.html5,
			switch(control.mode, moveto, drag, follow);
			skin_changecontrolmode_updatecaption();
		  ,
			switch(control.mode, moveto, drag);
		);
	</action>
		
	<!-- <action name="skin_changecontrolmode_updatecaption" autorun="onstart" devices="html5">
		txtadd(contextmenu.item[cc].caption,
			"Controlmode: ",
			"[span style=[sq]", calc(control.mode == 'drag' ? "text-decoration:underline" :""), "[sq]]",
			"Drag",
			"[/span]",
			" | ",
			"[span style=[sq]", calc(control.mode == 'follow' ? "text-decoration:underline" :""), "[sq]]",
			"Follow",
			"[/span]",
			" | ",
			"[span style=[sq]", calc(control.mode == 'moveto' ? "text-decoration:underline" :""), "[sq]]",
			"MoveTo",
			"[/span]",
			);
	</action> -->

	<action name="skin_view_look_straight">
		if(view.vlookat LT -80 OR view.vlookat GT +80,
			tween(view.vlookat, 0.0, 1.0, easeInOutSine);
			tween(view.fov,     100, distance(150,0.8));
		);
		skin_deeplinking_update_url(1.0);
	</action>

	<action name="skin_view_normal">
		skin_view_look_straight();
		tween(view.architectural, 0.0, distance(1.0,0.5));
		tween(view.pannini,       0.0, distance(1.0,0.5));
		tween(view.distortion,    0.0, distance(1.0,0.5));
	</action>

	<action name="skin_view_fisheye">
		skin_view_look_straight();
		tween(view.architectural, 0.0,  distance(1.0,0.5));
		tween(view.pannini,       0.0,  distance(1.0,0.5));
		tween(view.distortion,    0.35, distance(1.0,0.5));
	</action>

	<action name="skin_view_architectural">
		skin_view_look_straight();
		tween(view.architectural, 1.0, distance(1.0,0.5));
		tween(view.pannini,       0.0, distance(1.0,0.5));
		tween(view.distortion,    0.0, distance(1.0,0.5));
	</action>

	<action name="skin_view_stereographic">
		skin_view_look_straight();
		tween(view.architectural, 0.0, distance(1.0,0.5));
		tween(view.pannini,       0.0, distance(1.0,0.5));
		tween(view.distortion,    1.0, distance(1.0,0.8));
	</action>

	<action name="skin_view_pannini">
		skin_view_look_straight();
		tween(view.architectural, 0.0, distance(1.0,0.5));
		tween(view.pannini,       1.0, distance(1.0,0.8));
		if(view.distortion LT 0.1,
			tween(view.distortion, 1.0, distance(1.0,0.8));
		);
	</action>

	<action name="skin_view_littleplanet">
		tween(view.architectural, 0.0, distance(1.0,0.5));
		tween(view.pannini,       0.0, distance(1.0,0.5));
		tween(view.distortion,    1.0, distance(1.0,0.8));
		tween(view.fov,           150, distance(150,0.8));
		tween(view.vlookat,        90, distance(100,0.8));
		tween(view.hlookat, calc(view.hlookat + 100.0 + 45.0*random), distance(100,0.8));
		skin_deeplinking_update_url(1.0);
	</action>
	
	
	<action name="skin_followmouse_init" scope="private:skinfollowmouse" autorun="onstart" devices="desktop.and.no-touch">
		if(global.skin_settings.followmousecontrol,
			set(followspeed, 0.05);
			set(followrange, 10);
			set(followfactor, 1.0);
			set(track_ry, 0);
			set(track_rx, 0);
			set(global.events[skin_followmouse].keep, true);
			set(global.events[skin_followmouse].onviewchanged, set(global.view.haschanged,true); );
			set(global.events[skin_followmouse].onviewchange, skin_followmouse_onviewchange() );
			set(global.events[skin_followmouse].onmousedown, scope(private:skinfollowmouse, stopdelayedcall(followmouse_reenable); tween(followfactor,0.0,0.2); ); );
			set(global.events[skin_followmouse].onmouseup, scope(private:skinfollowmouse, delayedcall(followmouse_reenable, 1.0, tween(followfactor,1.0,3.0) ); ); );
		  );
	</action>
	
	<action name="skin_followmouse_onviewchange" scope="private:skinfollowmouse">
		if(global.mouse.x != 0 AND global.mouse.y != 0,
			Math.tan(zoomscale, calc(global.view.vfov * 0.5 * Math.PI / 180.0));
			calc(zoomscale, 1.0 / zoomscale);
			Math.max(zoomscale, 1.0);
			calc(new_ry, followfactor/zoomscale * followrange * (global.mouse.x / global.stagewidth - 0.5));
			calc(new_rx, followfactor/zoomscale * followrange * (global.mouse.y / global.stageheight - 0.5));
			calc(track_ry, track_ry*(1.0-followspeed) + new_ry*followspeed);
			calc(track_rx, track_rx*(1.0-followspeed) + new_rx*followspeed);
			copy(global.view.ry, track_ry);
			copy(global.view.rx, track_rx);
		);
	</action>
	
	
	
	<!-- A helper script for getting into fullscreen mode on the iPhone. -->
	
	<events name="iphone_fullscreen_swipe" keep="true" devices="iphone"
			oniphonefullscreen="iphone_fullscreen_swipe();"
			/>
		
	<action name="iphone_fullscreen_swipe" scope="localonly">
		if(global.display.iphonefullscreen GT 0,
			if(!global.layer[iphone_fullscreen_info],
				addlayer('iphone_fullscreen_info', infolayer);
				set(infolayer, type=text, css='color:#FFFFFF; font-size:26px; font-weight:bold; text-align:center;', txtshadow='0 0 8 0x000000 1', mergedalpha=false, bgcolor=0x000000, bgalpha=0.7, bgcapture=true, align=lefttop, x=0, y=0, width=100%, height=100%, vcenter=true, keep=true, zorder=9999, safearea=false);
				if(global.display.iphonefullscreen == 1,
					set(infolayer.html, '[span style="font-size:60px;"]⇡[/span][br]Swipe Up');
				  ,
					set(infolayer.html, '[span style="font-size:60px;"]⇣ ⇡[/span][br]Swipe Down and Up');
				);
			);
		  ,
			removelayer('iphone_fullscreen_info');
		);
	</action>

	<!-- CODE MENU -->
	<krpano stagescale="calc:stagescale * 2" if="stagescale LT 1.0" devices="mobile" />

	
	<events name="skin_events" keep="true"
	        onxmlcomplete="skin_startup();"
	        onnewpano="hide_google_map();skin_showloading(true); skin_update_scene_infos(); "
	        onremovepano="skin_showloading(true);"
	        onloadcomplete="skin_showloading(false);"
	        onidle=""
	        onresizeonly="skin_onresize();"
	        onenterfullscreen.fullscreensupport=""
	        onexitfullscreen.fullscreensupport=""
	        onkeydown=""
	        />

	<action name="hide_google_map">
		if( xml.scene != 'scene_location',
			disable_layer(mapcontainer);
		);
	</action>

	<events name="onresize_changes_only" keep="true"
        onresize="
            if(last_stagewidth != stagewidth OR last_stageheight != stageheight,
               events.dispatch('onresizeonly');
            );
            copy(last_stagewidth, stagewidth);
            copy(last_stageheight, stageheight);
            "
        />

	<action name="skin_update_scene_infos">

		txtadd( layer[skin_title].html, '', get(scene[get(xml.scene)].title) , copy(layer[skin_title].html, scene[get(xml.scene)].title ); 
		delayedcall(0.1, set(layer[skin_title].visible,true) );

	</action>

	<action name="skin_showloading">
		set(layer[skin_loadingtext].visible, %1);
	</action>

	
	<action name="skin_startup">
		set(layer[skin_layer].visible, true);
	</action>	

	<layer name="skin_layer" keep="true" type="container" align="top" width="100%" maxwidth="100%" height="100%" maskchildren="true" visible="false" bgcapture="false" zorder="1">
		<layer name="skin_loadingtext" type="text" align="center" x="5" y="-5" html="loading..." visible="false" background="false" border="false" enabled="false" 
			css="calc:skin_settings.design_text_css + ' text-align:center; font-style:italic; font-size:22px; '"
			textshadow="" />
	</layer>


	<action name="skin_loadscene">
		hide_disclaimer();
		set(floorplanname, get(scene[%1].floorplan));
		if(floorplanname !== null,  

			set(layer[floorplans_container].state, maximized);
			toggleFloorPlanSize();

			set(floorplancurrent, get(scene[get(xml.scene)].floorplan ) );
			set(floorplannext, get(scene[%1].floorplan ) );

			set(spotname, get(scene[%1].spotname));
			set(heading, get(scene[%1].heading));

			if( floorplancurrent != floorplannext,

				set(varfloorplannames, get(floorplannames) );
				txtsplit( varfloorplannames, ',' , varfloorplansarray);

				for(set(counter_thumbs,0), counter_thumbs LT varfloorplansarray.count, inc(counter_thumbs),				
					disable_layer( get(varfloorplansarray[get(counter_thumbs)].value) );
				);	

				if( layer[floorplans_container].x == 0,
					
					set(floorplanwidth, get(layer[floorplans_container].width));
					mul(floorplanwidth, get(floorplanwidth), -1);

					set(fp_width, get(layer[get(floorplannext)].width) );
					set(fp_height, get(layer[get(floorplannext)].height) );

					tween(layer[floorplans_container].x,get(floorplanwidth),0.5,default,
						set(layer[floorplans_container].width, get(fp_width) );
						set(layer[floorplans_container].height, get(fp_height) );
						enable_layer(get(floorplanname));
						tween(layer[floorplans_container].x,0);
						updateradar(get(spotname), get(heading));
					);
					,

					set(layer[get(floorplanname)].alpha,0);
					set(layer[get(floorplanname)].enabled,true);
					set(layer[get(floorplanname)].visible,true);

					tween(layer[get(floorplanname)].alpha,1,0.5,default,
						tween(layer[floorplans_container].x, 0);
						updateradar(get(spotname), get(heading));
					);
				);
				
				,

				enable_layer(get(floorplanname));
				tween(layer[floorplans_container].x, 0);
				updateradar(get(spotname), get(heading));

			);

			,

			set(floorplanwidth, get(layer[floorplans_container].width));
			mul(floorplanwidth, get(floorplanwidth), -1);

			tween(layer[floorplans_container].x, get(floorplanwidth));
		);

		loadscene(get(scene[%1].name), null, MERGE,OPENBLEND(0.5, 0.0, 0.75, 0.05, linear));
		if(device.mobile, skin_hide_sidebar2());

		set(floorplanscene, get(scene[%1].floorplan_linkedscene));
		if(floorplanscene !== null, 
			set(bgcolor, 0x000000 );
			set(global.last_scene , get(scene[get(xml.scene)].name ) );		 

			set(layer[switchFullScreen].onclick, 

				save_last_lookat();
				
				skin_loadscene(get(floorplanscene));

				showcurrentlocation();		
			);			
		);

		skin_highlight_active_accordion();
		skin_highlight_active_scene();

	</action>

	<action name="show_active_scene_in_sidebar">

		txtsplit(get(menuindex) , '-', array_index_sasib);

		if(array_index_sasib.count == 1,
			
		);

		if(array_index_sasib.count == 2 OR array_index_sasib.count == 3,
			set(index_1_sasib, get(array_index_sasib[0].value) );	
			set(index_2_sasib, get(array_index_sasib[1].value) );	

			txtadd(string_accordion_sasib,'menu_container_',get(index_1_sasib));

			set(accordion_state_sasib, get(layer[get(string_accordion_sasib)].state));

			if(get(accordion_state_sasib) == 'closed',
				skin_toggle_accordion(get(index_1_sasib));
			);
		);
		if(array_index_sasib.count == 3,

			txtadd(string_active_menu_l2,'menu_container_',get(index_1_sasib),'-',get(index_2_sasib));

			set(accordion_state_l2_sasib, get(layer[get(string_active_menu_l2)].state));

			if(get(accordion_state_l2_sasib) == 'closed',
				skin_toggle_accordion_child(get(string_active_menu_l2));
			);			
		);		

		
	</action>

	<action name="skin_hotspot_loadscene">

		skin_loadscene(%1);
		show_active_scene_in_sidebar();
		
	</action>


	<action name="skin_highlight_active_accordion">

		for(set(i,0), i LT menuitems.count, inc(i),	
			txtadd(menuitem,'menu_item_',get(i));			
			set(layer[get(menuitem)].bgcolor, get(skin_settings.design_menu_item_color) );
			set(layer[get(menuitem)].bgalpha, get(skin_settings.design_menu_item_alpha) );
		);

		set(menuindex, get( scene[get(xml.scene)].menuindex ) );
		txtadd(menuitem,'menu_item_',get(menuindex));
		set(layer[get(menuitem)].bgcolor, get(skin_settings.design_menu_item_active_color) );
		set(layer[get(menuitem)].bgalpha, get(skin_settings.design_menu_item_active_alpha) );		
	</action>
	<action name="skin_highlight_active_scene">

		for(set(i,0), i LT scene.count, inc(i),
			txtadd(scenemenuitem,'menu_container_',get(i));
			set( layer[get(string_active_menu)].bgalpha, 0 );	
		);

		set(current_scene_menuindex , get(menuindex) );
		if(current_scene_menuindex == null,  
			set(menuindex, get( scene[get(global.last_scene)].menuindex ) );			
		);

		<!-- Màu active sub menu -->
		txtadd(string_active_menu,'menu_container_',get(menuindex));
		set( layer[get(string_active_menu)].bgalpha, 0.85 );
		set( layer[get(string_active_menu)].bgcolor, get(skin_settings.color_active_submenu) );		

	</action>


	<action name="skin_hide_sidebar2">

		if(device.mobile,
			set(layer[sidebarbg].enabled, false);
			set(layer[sidebarbg].visible, false);
			
			mul(menuwidth, get(stagewidth), -1);

			tween(layer[sidebar].x , get(menuwidth) , 0.8, easeoutexpo);
			wait(0.3);
			tween(layer[sidebar_minimized].x , 5, 0.8, easeoutexpo);
		);

		if(device.desktop OR device.tablet,
			mul(menuwidth, get(skin_settings.design_menu_width), -1);
			tween(layer[sidebar].x , get(menuwidth) , 0.8, easeoutexpo);
			tween(layer[sidebar_minimized].x , 0, 0.8, easeoutexpo);	
			tween(layer[skin_title].x, 0, 0.8, easeoutexpo);
			set(layer[skin_title].css, "text-align:left;font-size:20px;padding:20px 0 20px 80px;text-transform:uppercase;font-family:Montserrat;font-weight:500;color:#fff;" );
		);	
		hide_disclaimer();
	</action>

	<action name="skin_show_sidebar2">
		if(device.mobile,
			tween(layer[sidebar].x , 0, 0.8, easeoutexpo);
			tween(layer[sidebar_minimized].x , -60, 0.8, easeoutexpo);		
			set(layer[sidebarbg].enabled, true);
			set(layer[sidebarbg].visible, true);
		);

		if(device.desktop OR device.tablet,
			tween(layer[sidebar].x , 0, 0.8, easeoutexpo);
			tween(layer[sidebar_minimized].x , -60, 0.8, easeoutexpo);		
			tween(layer[skin_title].x, 297, 0.8, easeoutexpo);
			set(layer[skin_title].css, "text-align:left;font-size:20px;padding:20px 0 20px 80px;text-transform:uppercase;font-family:Montserrat;font-weight:500;color:#fff;" );
		);
	</action>

	<style name="style_accordion" 	
			type="container"
			y="40"
			bgalpha="0"
			bgcolor=""
			height="0"
			width="100%"
			enabled="true"
			visible="true"
			state="closed"
			keep="true" />

	<action name="skin_adjust_accordion_height" scope="local">

		set(scrollheight,0);

		for(set(i,0), i LT array_menuitems.count, inc(i),	
			txtadd(menuitem,'menu_container_',get(i));

			set( open_or_closed, get(layer[get(menuitem)].state) );
			
			if( open_or_closed == 'open',
				inc(scrollheight, get(layer[get(menuitem)].height_expanded) );
				
				for(set(i2,0), i2 LT layer[get(menuitem)].children_count , inc(i2), 

					txtadd(string_menu_loop_i2 ,'menu_container_', get(i) ,'-',get(i2) );

					set( child_open_or_closed, get(layer[get(string_menu_loop_i2)].state) );

					if( child_open_or_closed == 'open',
						inc(scrollheight, get(layer[get(string_menu_loop_i2)].height_expanded) );		
					);
				);


				,
				inc(scrollheight, get(layer[get(menuitem)].height) );
			);

		);


		if(device.desktop,
			set(logo_height, get(skin_settings.design_logo_height) );
			,
			set(logo_height, get(skin_settings.design_logo_height_mobile) );
		);


		if( scrollheight GT calc(stageheight - logo_height) , 
			set( layer[menuitemscontainer].height, get(scrollheight) );
			,
			set( layer[menuitemscontainer].height, calc(stageheight - logo_height) );
		);


		set(disclaimer_height, get(layer[skin_disclaimer_toggle].height) );		
		if(device.mobile, 
			set(layer[menuitemscontainermask].height, calc(stageheight - skin_settings.design_logo_height_mobile - disclaimer_height - 50));
			,
			set(layer[menuitemscontainermask].height, calc(stageheight - skin_settings.design_logo_height - disclaimer_height - 50));
		);

	</action>


	<action name="rotate_arrow" scope="local">	
		txtadd(string_arrow_to_animate,'menu_arrow_', %1 );
		tween( layer[get(string_arrow_to_animate)].rotate, %2 );			
	</action>

	<action name="return_menu_item_to_original_position" scope="local">
		tween( layer[%1].y, get(layer[%1].y_original)  , 0.3, easeoutquad, );
		delayedcall(0.3, 
			skin_adjust_accordion_height();
		);
	</action>

	<action name="open_accordion" scope="local">
		hide_disclaimer();
		subtxt(string_index, %1, 15, 3); 

		tween( layer[%1].height,get(layer[%1].height_expanded) , 0.3, easeoutquad  );	
		set( layer[%1].state , 'open' );		

		rotate_arrow( get(string_index), -180 );
	</action>


	<action name="close_accordion" scope="local">

		subtxt(string_index, %1, 15, 3);
		txtsplit(string_index, '-', array_index);

		if( get(array_index.count) == 1, 


			set(index_1, get(array_index[0].value) );

			tween( layer[%1].height, get(skin_settings.design_menu_item_thumb_height) , 0.3, easeoutquad  );				
			set( layer[%1].state , 'closed' );		


			rotate_arrow( get(index_1), 0 );

			return_menu_item_to_original_position(%1);

			set(menu_type, get(array_menuitems[get(index_1)].type) );

			if(menu_type == 'accordion',
				close_all_accordion_children(get(index_1));
			);
		);

		if( get(array_index.count) GT 1, 

			set(index_1, get(array_index[0].value) );
			set(index_2, get(array_index[1].value) );

			tween( layer[%1].height, get(skin_settings.design_menu_item_thumb_height) , 0.3, easeoutquad  );				
			set( layer[%1].state , 'closed' );

			rotate_arrow(get(string_index),0);

			txtadd(string_menu_parent_to_close ,'menu_container_', get(index_1) );

			tween( layer[get(string_menu_parent_to_close)].height, calc( get(layer[get(string_menu_parent_to_close)].height_expanded) ) , 0.3, easeoutquad  );						
		);
	</action>

	<action name="close_all_accordion_children" scope="local">

		set(scene_indexes_array, get(array_menuitems[%1].scenes) );

		for(set(counter_close,0), counter_close LT scene_indexes_array.count, inc(counter_close), 				

			txtadd(string_menu_loop_ca ,'menu_container_', %1 ,'-',get(counter_close) );

			tween( layer[get(string_menu_loop_ca)].height, get(skin_settings.design_menu_item_thumb_height) , 0.3, easeoutquad  );				
			set( layer[get(string_menu_loop_ca)].state , 'closed' );		

			return_menu_item_to_original_position(get(string_menu_loop_ca));

			
			txtadd(string_arrow_to_animate_ca, %1 , '-', get(counter_close) );
			rotate_arrow(get(string_arrow_to_animate_ca),0);

		);	
	</action>


	<action name="skin_toggle_accordion_child" scope="local">

		txtsplit( %1, ',' , array_scenes_l2);
		subtxt(string_index, %1, 15, 4);
		txtsplit(string_index, '-', array_index);

		set(index_l2, get(array_index[0].value) );
		set(index_l3, get(array_index[1].value) );

		set( accordion_state_of_clicked, get(layer[%1].state) );
		
		set( array_child_menu_object, get(array_menuitems[get(index_l2)].scenes) );


		for(set(i,0), i LT array_child_menu_object.count, inc(i),

			txtadd(string_menu_loop ,'menu_container_', get(index_l2) ,'-',get(i) );
			set( accordion_state_loop, get(layer[get(string_menu_loop)].state) );

			if( i == get(index_l3),


				if(get(accordion_state_loop) == 'closed',

					open_accordion(get(string_menu_loop));

					txtadd(string_menu_parent ,'menu_container_', get(index_l2) );
					set(new_height, calc( get(layer[get(string_menu_parent)].height_expanded) + get(layer[get(string_menu_loop)].height_expanded) - get(skin_settings.design_menu_item_thumb_height)  ) );

					tween( layer[get(string_menu_parent)].height, get(new_height)  , 0.3, easeoutquad  );	

				);

				if(get(accordion_state_loop) == 'open',			

					close_accordion(get(string_menu_loop));

				);

			);

			if( i != get(index_l3) , 
				tween( layer[get(string_menu_loop)].height, get(skin_settings.design_menu_item_thumb_height) , 0.3, easeoutquad  );				
				set( layer[get(string_menu_loop)].state , 'closed' );				

				txtadd(arrow_index_to_animate_ca, get(index_l2) ,'-',get(i) );
				rotate_arrow( get(arrow_index_to_animate_ca) , 0);

				return_menu_item_to_original_position(get(string_menu_loop));

			);


			if( i GT get(index_l3) , 
				if(get(accordion_state_of_clicked) == 'open',	
					return_menu_item_to_original_position(get(string_menu_loop));		
				);

				if(get(accordion_state_of_clicked) == 'closed',	

					set(height_of_opened_accordion, get(layer[%1].height_expanded) );
					tween( layer[get(string_menu_loop)].y,calc( layer[get(string_menu_loop)].y_original + height_of_opened_accordion - get(skin_settings.design_menu_item_thumb_height) )  , 0.3, easeoutquad );	

				);
			);
		);


		for(set(j,0), j LT array_menuitems.count, inc(j),	

			txtadd(string_menu_loop,'menu_container_',get(j));
			
			if( j GT get(index_l2) , 

				if(get(accordion_state_of_clicked) == 'open',	

					txtadd(string_menu_parent_l2 ,'menu_container_', get(index_l2) );
					set(height_of_parent_accordion_when_expanded , get(layer[get(string_menu_parent_l2)].height_expanded) );

					set(new_y, calc( layer[get(string_menu_loop)].y_original + height_of_parent_accordion_when_expanded - get(skin_settings.design_menu_item_thumb_height))); 

					tween( layer[get(string_menu_loop)].y, get(new_y) , 0.3, easeoutquad );
				);

				if(get(accordion_state_of_clicked) == 'closed',	

					set(scenes_object, get(array_menuitems[get(index_l2)].scenes) );
					set(move_by_parent, calc(scenes_object.count * get(skin_settings.design_menu_item_thumb_height) ) );

					set(scenes_child_object, get(scenes_object[get(index_l3)].scenes) );
					txtsplit( scenes_child_object, ',' , scenes_child_array);
					set(move_by_child, calc(scenes_child_array.count * get(skin_settings.design_menu_item_thumb_height) ) );

					set(y_offset, calc(move_by_parent +  move_by_child) );

					tween( layer[get(string_menu_loop)].y, calc( layer[get(string_menu_loop)].y_original + y_offset )  , 0.3, easeoutquad );	
				);
			);

		);		
		return_menu_item_to_original_position(%1);
	</action>

	<action name="skin_toggle_accordion" scope="local">

		set( index_clicked, %1 );

		txtadd(string_menu_clicked,'menu_container_',get(index_clicked));

		set( accordion_state_of_clicked, get(layer[get(string_menu_clicked)].state) );

		for(set(i,0), i LT array_menuitems.count, inc(i),	

			txtadd(string_menu_loop,'menu_container_',get(i));
			set( accordion_state_loop, get(layer[get(string_menu_loop)].state) );

			if( i == get(index_clicked),

				if(get(accordion_state_loop) == 'closed',
					open_accordion(get(string_menu_loop));
				);

				if(get(accordion_state_loop) == 'open',			
					close_accordion(get(string_menu_clicked));
				);
			);


			if( i != get(index_clicked) , 
				close_accordion(get(string_menu_loop));
			);


			if( i GT get(index_clicked) , 

				if(get(accordion_state_of_clicked) == 'open',	
					return_menu_item_to_original_position(get(string_menu_loop));
				);

				if(get(accordion_state_of_clicked) == 'closed',	

					set(height_of_opened_accordion, get(layer[get(string_menu_clicked)].height_expanded) );

					set(new_height, calc(layer[get(string_menu_loop)].y_original + height_of_opened_accordion - get(skin_settings.design_menu_item_thumb_height)) );

					tween( layer[get(string_menu_loop)].y, get(new_height) , 0.3, easeoutquad );	
				);
			);
		);

		return_menu_item_to_original_position(get(string_menu_clicked));
	</action>

	<action name="skin_add_menu_item_accordion_child" scope="local" args="menucontainer, arrayscenes" >

		txtsplit( arrayscenes, ',' , array_scenes_l2);
		subtxt(string_index, menucontainer, 15, 4);
		txtsplit(string_index, '-', array_index);

		set(index_l2, get(array_index[0].value) );
		set(index_l3, get(array_index[1].value) );

		set(y_position_nested_2, get(skin_settings.design_menu_item_thumb_height));	

		for( set(counter_accordion_l2,0), counter_accordion_l2 LT array_scenes_l2.count, inc(counter_accordion_l2),	

			set( index_child_scene, get(array_scenes_l2[get(counter_accordion_l2)].value) );


			set(rootscene_l2, get(scene[get(index_child_scene)].rootscene ));

			if(rootscene_l2 == null,  

				txtadd(string_menu_container_l2 ,'menu_container_', get(index_l2) ,'-',get(index_l3), '-' , get(counter_accordion_l2));

				addlayer(get(string_menu_container_l2));
				set(layer[get(string_menu_container_l2)].parent, %1 );
				set(layer[get(string_menu_container_l2)].y, get(y_position_nested_2) );
				assignstyle(layer[get(string_menu_container_l2)], 'style_menu_item');

				txtadd(string_menu_label_l2 ,'menu_label_', get(index_l2) ,'-',get(index_l3), '-' , get(counter_accordion_l2));
				addlayer(get(string_menu_label_l2));
				assignstyle(layer[get(string_menu_label_l2)], 'style_menu_label');
				set(layer[get(string_menu_label_l2)].parent, get(string_menu_container_l2));
				set(layer[get(string_menu_label_l2)].padding, '0 0 0 40');


				set(onclick,'skin_loadscene(');
				txtadd(onclick,  get(scene[get(index_child_scene)].name) );
				txtadd(onclick,  ');' );
				set(layer[get(string_menu_label_l2)].onclick, get(onclick) );

				set(menu_label, get(scene[get(index_child_scene)].menu_title ));

				if(menu_label !== null,
					set(layer[get(string_menu_label_l2)].html, get(menu_label) );
					,
					set(layer[get(string_menu_label_l2)].html, get(scene[get(index_child_scene)].title) );
				);


				txtadd(menu_index_string, get(index_l2) ,'-',get(index_l3),'-',get(counter_accordion_l2));
				set(scene[get(index_child_scene)].menuindex, get(menu_index_string) );	

				inc(y_position_nested_2, get(skin_settings.design_menu_item_thumb_height) );

				,
				set(scene[get(index_child_scene)].menuindex, get(scene[get(rootscene_l2)].menuindex) );	

			);
		);

		set(layer[%1].height, get(skin_settings.design_menu_item_thumb_height) );

		set(layer[%1].height, get(skin_settings.design_menu_item_thumb_height) );
		set(layer[%1].height_expanded, get(y_position_nested_2) );
		set(layer[%1].children_count, get(array_scenes_l2.count) );
		set(layer[%1].state, "closed" );
	</action>

	<action name="skin_add_menu_item_accordion" scope="local" args="index_parent, parent_container_id, array_scenes, has_children">

		txtadd(string_menu_arrow,'menu_arrow_', get(index_parent) );

		addlayer(get(string_menu_arrow));
		set(layer[get(string_menu_arrow)].parent, get(parent_container_id) );
		assignstyle(layer[get(string_menu_arrow)], 'style_arrowcontainer');	

		txtadd(string_menu_arrow_child,'menu_arrow_child_', get(index_parent) );
		addlayer(get(string_menu_arrow_child));
		assignstyle(layer[get(string_menu_arrow_child)], 'style_arrow');	
		set(layer[get(string_menu_arrow_child)].parent, get(string_menu_arrow) );
		
		set(y_position, get(skin_settings.design_menu_item_thumb_height));		

		for( set(counter_accordion,0), counter_accordion LT array_scenes.count, inc(counter_accordion),	

			set(index, get(array_scenes[get(counter_accordion)].value) );

			set(rootscene, get(scene[get(index)].rootscene ));

			if(rootscene == null,  

				txtadd(string_menu_container,'menu_container_', get(index_parent) ,'-',get(counter_accordion));
				
				addlayer(get(string_menu_container));
				set(layer[get(string_menu_container)].parent, get(parent_container_id) );
				set(layer[get(string_menu_container)].y, get(y_position) );
				set(layer[get(string_menu_container)].y_original, get(y_position) );
				assignstyle(layer[get(string_menu_container)], 'style_menu_item');


				txtadd(string_menu_label,'menu_label_', get(index_parent) ,'-',get(counter_accordion));
				addlayer(get(string_menu_label));

				assignstyle(layer[get(string_menu_label)], 'style_menu_label2');

				set(layer[get(string_menu_label)].parent, get(string_menu_container));
				set(layer[get(string_menu_label)].padding, '0 0 0 20');


				if(has_children !== null AND has_children == true,

					set(menu_label, get(array_scenes[get(counter_accordion)].label) );
					set(layer[get(string_menu_label)].html, get(menu_label) );

					txtadd(string_menu_arrow_l2,'menu_arrow_', get(index_parent), '-' , get(counter_accordion));

					addlayer(get(string_menu_arrow_l2));
					set(layer[get(string_menu_arrow_l2)].parent, get(string_menu_container) );
					assignstyle(layer[get(string_menu_arrow_l2)], 'style_arrowcontainer');	

					txtadd(string_menu_arrow_l2_child,'menu_arrow_l2_child_', get(index_parent), '-' , get(counter_accordion) );
					addlayer(get(string_menu_arrow_l2_child));
					assignstyle(layer[get(string_menu_arrow_l2_child)], 'style_arrow');	
					set(layer[get(string_menu_arrow_l2_child)].parent, get(string_menu_arrow_l2) );

					set(onclick,'');	
					txtadd(onclick, 'skin_toggle_accordion_child(' );
					txtadd(onclick, get(string_menu_container) );
					txtadd(onclick, ');' );
					set(layer[get(string_menu_label)].onclick,  get(onclick) );		

					skin_add_menu_item_accordion_child( get(string_menu_container) , get(array_scenes[get(counter_accordion)].scenes) );

				);

				if(has_children == null OR has_children == false,

					set(menu_label, get(scene[get(index)].menu_title ));

					if(menu_label !== null,
						set(layer[get(string_menu_label)].html, get(menu_label) );
						,
						set(layer[get(string_menu_label)].html, get(scene[get(index)].title) );
					);

					set(onclick,'');	
					txtadd(onclick, 'skin_loadscene(' );
					txtadd(onclick, get(scene[get(index)].name) );
					txtadd(onclick, ');' );
					set(layer[get(string_menu_label)].onclick,  get(onclick) );					

					txtadd(menu_index_string, get(index_parent) ,'-',get(counter_accordion));
					set(scene[get(index)].menuindex, get(menu_index_string) );					
				);


				inc(y_position, get(skin_settings.design_menu_item_thumb_height) );		
			);
		);

		set(layer[get(parent_container_id)].height, get(skin_settings.design_menu_item_thumb_height) );
		set(layer[get(parent_container_id)].height_expanded, get(y_position) );
		set(layer[get(parent_container_id)].children_count, get(array_scenes.count) );
		set(layer[get(parent_container_id)].state, "closed" );
	</action>

	<action name="skin_add_menu_items" scope="local">

		set(y_position, 0);

		for(set(counter_toplevel ,0), counter_toplevel LT array_menuitems.count, inc(counter_toplevel),	

			txtadd(string_menu_container,'menu_container_',get(counter_toplevel));
			txtadd(string_menu_label,'menu_label_',get(counter_toplevel));
			
			set(label, get(array_menuitems[get(counter_toplevel)].label) );

			addlayer(get(string_menu_container));
			set(layer[get(string_menu_container)].parent, menuitemscontainer );
			set(layer[get(string_menu_container)].y, get(y_position) );
			set(layer[get(string_menu_container)].y_original, get(y_position) );
			
			assignstyle(layer[get(string_menu_container)], 'style_menu_item');

			addlayer(get(string_menu_label));
			set(layer[get(string_menu_label)].parent, get(string_menu_container) );
			set(layer[get(string_menu_label)].html, get(label) );

			assignstyle(layer[get(string_menu_label)], 'style_menu_label');	

			set(menuitemtype, get(array_menuitems[get(counter_toplevel)].type) );

			if(menuitemtype == 'single-scene', 

				set(scene_index, get(array_menuitems[get(counter_toplevel)].scenes) );

				set(onclick,'skin_loadscene(');
				txtadd(onclick,  get(scene[get(scene_index)].name) );
				txtadd(onclick,  ');' );
				set(layer[get(string_menu_label)].onclick, get(onclick) );

				set(scene[get(scene_index)].menuindex, get(counter_toplevel) );				
				set(layer[get(string_menu_container)].height_expanded, get(skin_settings.design_menu_item_thumb_height) );
				set(layer[get(string_menu_container)].state, "closed" );	
						
			);

			if(menuitemtype == 'multiple-scenes', 

				set(scene_indexes_string, get(array_menuitems[get(counter_toplevel)].scenes) );
				txtsplit( scene_indexes_string, ',' , scene_indexes_array);

				set(onclick,'');
				txtadd(onclick, 'skin_toggle_accordion(' );
				txtadd(onclick,  get(counter_toplevel) );
				txtadd(onclick,  ');' );
				set(layer[get(string_menu_label)].onclick, get(onclick) );

				skin_add_menu_item_accordion(get(counter_toplevel), get(string_menu_container) , get(scene_indexes_array) );
			);

			if(menuitemtype == 'accordion', 

				set(array_accordion, get(array_menuitems[get(counter_toplevel)].scenes) );

				set(onclick,'');
				txtadd(onclick, 'skin_toggle_accordion(' );
				txtadd(onclick,  get(counter_toplevel) );
				txtadd(onclick,  ');' );
				set(layer[get(string_menu_label)].onclick, get(onclick) );

				set(hasChildren, true);

				skin_add_menu_item_accordion(get(counter_toplevel), get(string_menu_container) , get(array_accordion), get(hasChildren) );
			);
			inc(y_position, get(skin_settings.design_menu_item_thumb_height));	
		);	 
	</action>

	<!-- Label menu (chữ menu) -->
	<style name="style_menu_item"
		type="container"
		align="top"	
		background="true"
		children="true"
		bgalpha="get:skin_settings.design_menu_item_alpha"
		bgcolor="get:skin_settings.design_menu_item_color"		
		height="get:skin_settings.design_menu_item_thumb_height"
		width="get:skin_settings.design_menu_width"
		keep="true"
		maskchildren="true" />

	<style name="style_menu_item" 
		devices="mobile"
		width="100%"
		/>		


	<style name="style_menu_item_active" 
			bgalpha="get:skin_settings.design_menu_item_active_alpha"
			bgcolor="get:skin_settings.design_menu_item_active_color" />

	<style name="style_menu_label" 
			type="text"
			align="top"
			y="0"
			padding="0"
			vcenter="true"
			css="font-size:15px;text-transform:uppercase;letter-spacing:1px;padding-left:10px;font-family:Montserrat;font-weight:400;color:#fff;"
			bgalpha="0"
			height="get:skin_settings.design_menu_item_thumb_height"
			keep="true"
			enabled="true"
			wordwrap="true"
			onloaded=""
			width="100%" />	
	<!-- CSS Sub menu -->
	<style name="style_menu_label2" 
			type="text"
			align="top"
			y="0"
			padding="0"
			vcenter="true"
			css="font-size:14px;letter-spacing:1px;padding-left:10px;font-family:Montserrat;font-weight:300;color:#fff;"
			bgalpha="0"
			height="get:skin_settings.design_menu_item_thumb_height"
			keep="true"
			enabled="true"
			wordwrap="true"
			onloaded=""
			width="100%" />	

	<style name="style_arrowcontainer" 
			type="container"
			keep="true"
			width="100"
			height="50"
			y="20"
			x="20"
			zorder="9999"
			enabled="true"
			align="topright"
			edge="center"
			background="true"
			bgcolor="0xFF00000"
			bgalpha="0"
			bgcapture="true"
			onloaded=""
			maskchildren="true"
			scale="0.14"
			scalechildren="true" />

	<style name="style_arrow" 
			type="container"
			keep="true"
			y="-50"
			width="70"
			height="70"
			bgcolor="get:skin_settings.design_menu_item_arrow_color"
			bgalpha="1"
			zorder="9999"
			enabled="true"
			bgroundedge="0"
			bgcapture="true"
			edge="topleft"
			rotate="45"
			onloaded=""
			x="50" />


		<layer name="gradienttop" 
			align="topcenter"
			devices="mobile"
			type="text"
			html=""
			css="background: linear-gradient(to bottom, rgba(0, 0, 0, 0.5) 0%,rgba(0,0,0,0) 100%);padding:20px;"
			keep="true"
			height="100"
			width="105%"
			bgalpha="0"
			enabled="false"
			x="0" y="-5" />
			

	<layer name="sidebar_minimized" 
			type="container" 
			width="40" x="0"
			height="100%"
			align="left"
			keep="true"
			visible="true"
			enabled="true"
			bgalpha="0.4"
			onclick="skin_show_sidebar2()"
			bgcolor="0xFFFFFF"
	       	zorder="99"
	       	handcursor="true"
	       	bgcapture="true"			
			maskchildren="false">
		<layer name="sidebar_show" 
				type="container"
				bgcolor="0x000000"
				bgalpha="0"
				edge="center"
				align="center"
				width="27"
				height="21"
				onclick="skin_show_sidebar2()">
				<!-- <layer name="line1" type="container" height="3" width="100%" bgcolor="get:skin_settings.design_menu_burger_color" bgalpha="1" align="top" />
				<layer name="line2" type="container" height="3" width="100%" bgcolor="get:skin_settings.design_menu_burger_color" bgalpha="1" align="center" />
				<layer name="line3" type="container" height="3" width="100%" bgcolor="get:skin_settings.design_menu_burger_color" bgalpha="1" align="bottom" /> -->
				<layer name="icon_right" url="left_circle.png" align="center" x="20" x.mobile="0" scale="0.25" onclick="skin_show_sidebar2()" rotate="180"/>
		</layer>

	</layer>


	<layer name="sidebar_minimized" devices="mobile" align="centerleft" height="40" width="40" x="5" y="0" bgroundedge="100">
		<layer name="sidebar_show" scale="0.7" x="20" y="20" align="topright" />
	</layer>

	<layer name="sidebar" 
			type="container" 
			width="get:skin_settings.design_menu_width"
			height="100%"
			x="-300"
			align="left"
			keep="true"
			visible="true" 
			enabled="true"
			bgalpha="0.9"
			bgcolor="0x271756"
			zorder="9997"
			maskchildren="true" >

		<layer name="sidebar_hide" 
				x="30"
				y="30"
				width="45"
				height="45"
				type="container"
				bgalpha="0"
				bgcolor="0x000000"
				enabled="true"
		 		scale="0.8"
		 		edge="center"
		 		handcursor="true"
		 		onclick="skin_hide_sidebar2"
		 		bgroundedge="100"
		 		
		 		zorder="9999"
				align="topright" 
				alpha="1"
				onloaded=""
				bgcapture="true">
			<!-- <layer name="slashforward" type="container" height="20" width="3" bgcolor="get:skin_settings.design_menu_close_color" bgalpha="1" rotate="45" align="center" onloaded="" />
				<layer name="slashbackward" type="container" height="20" width="3" bgcolor="get:skin_settings.design_menu_close_color" bgalpha="1" rotate="-45" align="center" onloaded="" /> -->

			<!-- <layer name="slashbackward" parent="sidebar_hide" url="plugins/textfield.swf" align="center" html="X" css="text-align:center; color:#ffffff; font-family:Montserrat; font-weight:bold; font-size:25px;text-align:center;" 
			handcursor="true"
			enabled="false"
			background="false" />  -->

			<layer name="slashbackward" parent="sidebar_hide" url="right_circle.png" align="center" x="0" scale="0.25" onclick="skin_hide_sidebar2()"/>

		</layer>

		<layer name="sidebar_logo" 
				y="35" y.mobile="15"
				type="image"
				url="logo.png" 
				onclick="skin_hide_sidebar2"
				scale="0.2" scale.mobile="0.18"
				align="topcenter" />

		<layer name="thongtin_utc" url="%SWFPATH%/plugins/textfield.swf" align="bottomcenter" x="0" y="10" width="get:skin_settings.design_menu_width" html="Trường Đại Học Giao Thông Vận Tải[br] Phân hiệu TP.HCM" css="text-align:center; color:#ffffff; font-family:Montserrat; font-weight:bold; font-size:10px;" handcursor="true" enabled="false" background="false" /> 

		<layer name="menuitemscontainermask"
				type="container"
				y="get:skin_settings.design_logo_height"
				y.mobile="get:skin_settings.design_logo_height_mobile"
				width="get:skin_settings.design_menu_width"
				height="calc:stageheight - skin_settings.design_logo_height"
				height.mobile="calc:stageheight - skin_settings.design_logo_height_mobile"
				maskchildren="true" >
		
			<layer name="menuitemscontainer"
		       url.html5="%SWFPATH%/plugins/scrollarea.js"
		       align="top" width="get:skin_settings.design_menu_width" height="1000"
		       direction="v"
		       draggable="true"
		       capturechildren="true"
		       maskchildren="true"
		       mwheel="true"
		       onscroll="skin_updatethumbscroll"
		       onhover_autoscrolling="false"
		       overscroll="1.0"
		       friction="0.95"
		       acceleration="0.08"
		       returnacceleration="0.15"
		       momentum="0.06" 		
		       visible="true"
		       enabled="true" 
		       />
		    <layer name="skin_thumbs_scrollindicator" type="container" bgcolor="get:skin_settings.design_scrollbar_color"
		    	bgalpha="0.8" align="rightttop" width="5" y="0" height="20" bgroundedge="10"
		    	visible="false" enabled="false" />
	   	</layer>
   	
	</layer>

	<action name="hide_disclaimer">
		tween(layer[skin_disclaimer].y , -170, 0.8, easeoutexpo);
	</action>

	<layer name="sidebar" 
				devices="mobile" 
				align="topleft"
				width="get:skin_settings.design_menu_width_mobile" >
		<layer name="sidebar_hide" 
			crop="0|0|64|64" align="topright" />
		<layer name="menuitemscontainermask"
				width="get:skin_settings.design_menu_width_mobile" >
			<layer name="menuitemscontainer" width="get:skin_settings.design_menu_width_mobile" />
		</layer>
	</layer>
	<!-- Làm mở khi bắt đầu mobile -->
	<!-- <layer name="sidebarbg"
	       type="container"
	       keep="true"
	       visible="true"
	       enabled="true"
	       devices="mobile"
	       width="100%"
	       height="100%"
	       scale="1.0"
	       alpha="1"
	       bgcolor="0x000000"
	       bgalpha="0.75"
	       onclick="skin_hide_sidebar2()"
	       zorder="1"
	       handcursor="true"
	       bgcapture="true" />	 -->

	<action name="skin_nextscene_loop">
		add(newsceneindex, scene[get(xml.scene)].index, %1);
		sub(lastsceneindex, scene.count, 1);
		if(newsceneindex LT 0, copy(newsceneindex,lastsceneindex));
		if(newsceneindex GT lastsceneindex, set(newsceneindex,0));
		skin_hotspot_loadscene(get(newsceneindex));
	</action>


	<action name="skin_updatethumbscroll" scope="local">
		set(padding,0);

		if(caller.hoverflow GT 0,
			set(layer[skin_thumbs_scrollindicator].visible, true);

			sub(ih,caller.pixelheight,caller.hoverflow);
			div(ph,ih,caller.pixelheight);
			div(py,caller.toverflow ,caller.hoverflow);
			mul(ph,ih);
			copy(layer[skin_thumbs_scrollindicator].height, ph);
			sub(ih,ph);
			sub(ih,padding);
			mul(py,ih);
			add(py,padding);		
			copy(layer[skin_thumbs_scrollindicator].y, py);
			,
			set(layer[skin_thumbs_scrollindicator].visible, false);
		);
		
	</action>

	<style name="skin_base" url="vtourskin-new.png"/>
	<style name="skin_base_white" url="vtourskin-new.png"/>

	<layer name="skin_title" type="text" align="topleft" x="0" y="-5" zorder="4" enabled="false" 
		background="false" border="false" 
		css="text-align:left;font-size:20px;padding:20px 0 20px 80px;text-transform:uppercase;font-family:Montserrat;font-weight:400;color:#fff;"
		width="100%"
		textshadow="" 
		visible="true"  
		keep="true" />
	<layer name="skin_title"
		css="text-align:center;font-size:12px;text-transform:uppercase;letter-spacing:1px;font-family:Montserrat;font-weight:500;color:#fff;"
		y="5"
		edge="topright"
		align="topright"
		devices="mobile" />

	<action name="onintroclose">
		if( device.desktop OR device.tablet, 
			skin_show_sidebar2();
		);
	</action>

	
	
	<style name="skin_tooltips"
	       onover.mouse="copy(layer[skin_tooltip].html, tooltip);
	                     set(layer[skin_tooltip].visible, true);
	                     tween(layer[skin_tooltip].alpha, 1.0, 0.1);
	                     asyncloop(hovering, copy(layer[skin_tooltip].x,mouse.stagex); copy(layer[skin_tooltip].y,mouse.stagey); );"
	       onout.mouse="tween(layer[skin_tooltip].alpha, 0.0, 0.1, default, set(layer[skin_tooltip].visible,false), copy(layer[skin_tooltip].x,mouse.stagex); copy(layer[skin_tooltip].y,mouse.stagey); );"
	       />	
	<layer name="skin_tooltip" keep="true"
	       type="text"
	       parent="STAGE"
	       visible="false" alpha="0" enabled="false" zorder="2"
	       align="lefttop" edge="bottom" oy="-2" width="200"
	       background="false" bgcolor="0xFFFFFF" bgalpha="1.0"
	       border="false" bordercolor="0x000000" borderalpha="1.0" borderwidth="1.0" roundedge="0"
	       shadow="0.0" shadowrange="4.0" shadowangle="45" shadowcolor="0x000000" shadowalpha="1.0"
	       textshadow="" textshadowrange="6.0" textshadowangle="90" textshadowcolor="0x000000" textshadowalpha="1.0"
	       css="color:#fff; text-align:center; font-size:18px; font-weight:bold;text-shadow:1px 1px 1px #000000;'"
	       html=""
	       />

	<style name="distortedText" enabled="false" type="text" keep="false" edge="center" distorted="true" alpha="1"
		renderer="webgl" css="font-family:Montserrat; font-size:16px; color:#FFFFFF;text-align:center" vcenter="false" 
		padding="4" wordwrap="true" bg="false" bgcolor="0x000000" bgalpha="1.0" bgborder="0" bgroundedge="0" 
		bgshadow="" txtshadow="0 0 6 0x000000 1" mergedalpha="true" oversampling="2.0" mipmapping="true"  onautosized=""/>

	<style name="distortedButton" enabled="true" type="text" keep="false" edge="center" distorted="true" alpha="1"
		renderer="webgl" css="font-family:Arial; font-size:14px; color:#FFFFFF;text-align:center" vcenter="false" 
		padding="6" wordwrap="true" bg="true" bgcolor="get:skin_settings.design_highlight_color" bgalpha="0.8" bgborder="" bgroundedge="4" 
		bgshadow="" txtshadow="0" mergedalpha="true" oversampling="2.0" mipmapping="true"  onautosized=""/>

	<plugin name="pp_blur" keep="true" url="%VIEWER%/plugins/pp_blur.js" enabled="true" range="0.0" linearrgb="false" order="1" phase="2"/>
	<style name="infospot" type="text" css="color:#FFFFFF; font-size:36px; font-weight:bold; text-align:center;" width="80" height="80" bgroundedge="42" bgalpha="0.75" bgcolor="0x01532d" bgborder="1 0xFFFFFF 1" bgshadow="0 0 16 0x0 0.5" txtshadow="0 0 3 0x0 1.0" mergedalpha="false" vcenter="true" oversampling="2" mipmapping="true" zoom="true" distorted="true"/>
	<action name="circlepos" scope="localonly" args="pos, total"> calc(caller.ox, -100 * cos((pos-1)/total * Math.PI * 2.0) ); calc(caller.oy, -100 * sin((pos-1)/total * Math.PI * 2.0) ); </action>

		<action name="popup" scope="private:POPUP" args="type, content, width, height, scrollbars"><![CDATA[
			if(popup, break(); );
			addlayer('popup', popup);
			set(popup,
				type=container,
				width=100%,
				height=100%,
				align=center,
				bgcapture=true,
				maskchildren=true,
				capture=true,
				handcursor=false,
				zorder=99,
				onclick=popup_close(),
				alpha=0
			);

			if(type == 'html',
				copy(popup.datacontent, content);
				calc(popup.onloaded, 'add_html_code(get(datacontent),'+scrollbars+');');

			  ,type == 'iframe',
				calc(popup.datacontent, '<iframe style="position:absolute;width:100%;height:100%;top:0px;left:0px;" src="'+content+'" frameborder="0" allowfullscreen></iframe>');
				calc(popup.onloaded, 'add_html_code(get(datacontent),'+scrollbars+');');

			  ,type == 'image',
			 	set(popup,
			 		bgcolor=0x000000,
			 		bgalpha=0.8,
			 	);

				addlayer('popup_overlay', popup_overlay);
				set(popup_overlay,
					type=container,
					width=calc(min(width,global.stagewidth*0.9)),
					height=calc(min(height,global.stageheight*0.8)),
					align=center,
					bgborder='1 0x000000 1',
					bgcolor=0xFFFFFF,
					bgalpha=1,
					bgshadow='0 10 20 0x000000 0.5',
					bgcapture=true,
					maskchildren=true,
					capture=true,
					handcursor=false,
					zorder=99,
					alpha=1,
					parent=get(popup.name),

				);

				addlayer("popup_image", img);
				set(img,
					url=get(content),
					align=center,
					width=-20, height=-20,
					parent=get(popup_overlay.name),
					onclick='popup_close()',
					onloaded='popup_imageloaded()'
				);

				addlayer("popup_close_button", btnclose);
				set(btnclose,
					type='text',
					html='X',
					align='rightttop',
					css='text-align:left; color:#ffffff; font-family:Montserrat; font-weight:bold; font-size:30px;' ,
					x=10, 
					y=10,
					parent=get(popup.name),
					onclick='popup_close()',
					zorder=9999,
					handcursor=true,
					autoheight=true,
					keep=true,
					enabled=true,
					visible=true,
					background=false,
				);	

		

						
			);

			tween(global.plugin[pp_blur].range, 40.0);
			delayedcall(0.2, tween(global.layer[popup].alpha, 1.0); );

			set(global.events[popup].onclick,
				popup_close();
			);
		]]></action>

	<action name="popup_close"> set(global.events[popup].name, null); tween(global.plugin[pp_blur].range, 0.0); tween(global.layer[popup].alpha, 0.0, 0.25, default, removelayer('popup', true); scope(private:POPUP, delete(popup); ); ); </action>
	<action name="popup_imageloaded" scope="private:POPUP">
		calc(imgw, caller.imagewidth + 20);
		calc(imgh, caller.imageheight + 20);
		calc(maxw, global.stagewidth*0.9);
		calc(maxh, global.stageheight*0.8);
		if(imgw GT maxw,
			calc(imgh, round(imgh * maxw / imgw));
			copy(imgw, maxw);
		);
		if(imgh GT maxh,
			calc(imgw, round(imgw * maxh / imgh));
			copy(imgh, maxh);
		);

		set(global.layer[get(caller.parent)], width=get(imgw), height=get(imgh) );
	</action>	
	<!-- <include url="%SWFPATH%/plugins/webvr.xml" devices="html5" /> -->
	
	<!-- overwrite some settings from the webvr.xml for the skin integration -->
	<plugin name="WebVR" keep="true" devices="html5"
	        pluginurl="%SWFPATH%/plugins/webvr.js"
	        url=""
	        multireslock.desktop="true"
	        multireslock.mobile.or.tablet="false"
	        mobilevr_support="true"
	        mobilevr_fake_support="true"
	        onavailable="skin_webvr_onavailable();"
	        onentervr="skin_showloading(false); webvr_onentervr(); skin_webvr_setup(); skin_reloadscene_webvr();"
	        onexitvr="webvr_onexitvr(); skin_webvr_setup(); skin_reloadscene_webvr();"
	        />

	<!-- webvr button style (adjust to match skin style) -->
	<style name="webvr_button_style"
	       bgroundedge="calc:skin_settings.design_bgroundedge"
	       bgcolor="get:skin_settings.design_bgcolor" bgalpha="get:skin_settings.design_bgalpha"
	       bgborder="get:skin_settings.design_bgborder"
	       bgshadow="get:skin_settings.design_bgshadow"
	       css="calc:skin_settings.design_text_css + ' font-size:' + 20*webvr_setup_scale*webvr_button_scale + 'px;'"
	       />

	<!-- show a 'rotate the device' info when the mobile device is in portrait orientation in VR mode -->
	<layer name="webvr_rotate_to_landscape_request" keep="true" vr="true" devices="mobile"
	       url="rotate_device.png" scale="0.5"
	       align="top" edge="center" y="28%"
	       autoalpha="true" alpha="0.0"
	       enabled="false"
	       />

	<events name="skin_webvr_events" keep="true" devices="html5"
	        onxmlcomplete="skin_webvr_set_startup_view()"
	        onresize.mobile="skin_webvr_act_as_gyro_in_portrait_mode();"
	        onloadcomplete="delayedcall(0.5, if(webvr.isenabled AND scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots, set(hotspot[skin_webvr_prev_scene].visible,true); set(hotspot[skin_webvr_next_scene].visible,true); ); );"
	        onviewchange=""
	        />

	<action name="skin_webvr_onavailable" scope="local">
		if(webvr.isgearvr,
			<!-- show a special enter VR screen for Gear VR browsers (Oculus Browser or Samsung Internet VR) -->
			set(layer[webvr_enterbutton], 
				align=center, y=0, padding='10 20', 
				css=calc(skin_settings.design_text_css + ' font-size:20px;text-align:center;'),
				html=calc('[i]'+global.title+'[/i][br][span style="font-size:40px"]Enter VR[span]'), 
			);
			skin_hideskin(instant);
		  ,
			<!-- remove the enter vr button from the webvr.xml -->
			removelayer(webvr_enterbutton);
		);
			
		<!-- update the skin buttons to add the skin vr button -->
		skin_arrange_buttons();
		
		<!-- call the original onavailable event from the webvr.xml -->
		webvr_onavailable();
	</action>

	<action name="skin_webvr_set_startup_view">
		if((webvr.isenabled OR plugin[skin_gyro].enabled) AND skin_settings.webvr_gyro_keeplookingdirection == false,
			skin_lookat( get(xml.view.hlookat) );
		);
	</action>

	<action name="skin_webvr_setup">
		if(webvr.isenabled,
			copy(skin_settings.loadscene_flags_backup, skin_settings.loadscene_flags);
			set(skin_settings.loadscene_flags, MERGE|KEEPVIEW|KEEPMOVING|NOPREVIEW);
			skin_webvr_act_as_gyro_in_portrait_mode(true);
			if(scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots,
				set(hotspot[skin_webvr_prev_scene].visible, true);
				set(hotspot[skin_webvr_next_scene].visible, true);
				set(events[skin_webvr_events].onviewchange, skin_webvr_menu_following());
			);
		  ,
			if(skin_settings.loadscene_flags_backup !== null, copy(skin_settings.loadscene_flags, skin_settings.loadscene_flags_backup); );
			if(layer[webvr_rotate_to_landscape_request], tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0); );
			set(hotspot[skin_webvr_prev_scene].visible, false);
			set(hotspot[skin_webvr_next_scene].visible, false);
			set(events[skin_webvr_events].onviewchange, null);
		);
	</action>

	<action name="skin_webvr_act_as_gyro_in_portrait_mode" scope="local" args="setupcall">
		if(device.mobile AND webvr.isenabled,
			div(aspect, stagewidth, stageheight);
			if(aspect != lastaspect OR setupcall == true,
				copy(lastaspect, aspect);
				if(stagewidth GT stageheight,
					<!-- landscape orientation - use stereo rendering and a direct/fast gyro sensor mode -->
					set(display.stereo, true);
					set(webvr.mobilevr_sensor_mode, 3);
					webvr.update();
					tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0);
				  ,
					<!-- portrait orientation - use normal rendering and a smoother/slower gyro sensor mode -->
					set(display.stereo, false);
					set(webvr.mobilevr_sensor_mode, 1);
					webvr.update();
					tween(layer[webvr_rotate_to_landscape_request].alpha, 1.0);
					delayedcall(3.0, tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 1.0); );
				);
			);
		  ,
			set(lastaspect, 0);
		);
	</action>

	<!-- VR scene switching hotspots -->
	<style name="skin_webvr_menu_style" depth="800" scale="0.5" distorted="true" ath="0" atv="45" alpha="0.5" />
	<hotspot name="skin_webvr_prev_scene" keep="true" style="skin_base|skin_webvr_menu_style" crop="0|64|64|64"  ox="-64" onover="tween(scale,0.6);" onout="tween(scale,0.5);" vr_timeout="750" onclick="skin_nextscene_loop(-1);" visible="false" devices="html5.and.webgl" />
	<hotspot name="skin_webvr_next_scene" keep="true" style="skin_base|skin_webvr_menu_style" crop="64|64|64|64" ox="+64" onover="tween(scale,0.6);" onout="tween(scale,0.5);" vr_timeout="750" onclick="skin_nextscene_loop(+1);" visible="false" devices="html5.and.webgl" />

	<!-- floating/following VR hotspots -->
	<action name="skin_webvr_menu_following" type="Javascript" devices="html5"><![CDATA[
		var hs1 = krpano.get("hotspot[skin_webvr_prev_scene]");
		var hs2 = krpano.get("hotspot[skin_webvr_next_scene]");
		if(!hs1.hovering && !hs2.hovering)
		{
			var f = 0.01;	// following speed factor
			var h = krpano.view.hlookat;
			var v = krpano.view.vlookat;
			var hsh = hs1.ath;
			var hsv = hs1.atv;
			h   = (h  -(h|0))   + (((h|0)  +360180)%360) - 180.0;
			v   = (v  -(v|0))   + (((v|0)  +360180)%360) - 180.0;
			hsh = (hsh-(hsh|0)) + (((hsh|0)+360180)%360) - 180.0;
			var dh = h - hsh;
			dh += (dh > 180) ? -360 : (dh < -180) ? 360 : 0
			hsh += dh*f;
			var a = Math.abs(v - hsv) / 90.0;
			a = 1.0 * Math.max(1.0 - 2.0*Math.sqrt(a), 0);
			v = v + 55.0 - v*1.5;
			hsv = hsv*(1.0 - f) + v*f;
			hs1.ath = hs2.ath = hsh;
			hs1.atv = hs2.atv = hsv;
			hs1.alpha = hs2.alpha = a;
		}
	]]></action>
	

</krpano>
